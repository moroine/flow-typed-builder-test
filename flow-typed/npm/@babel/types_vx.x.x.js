// flow-typed signature: 254fcb05c5d2f16a7a0a60083d0fb0e1
// flow-typed version: <<STUB>>/@babel/types_v7.19.0/flow_v0.187.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   '@babel/types'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module '@babel/types' {
  declare interface BaseComment {
value: string,
start: number,
end: number,
loc: SourceLocation,
type: "CommentBlock" | "CommentLine",
} export type CommentBlock = {
type: "CommentBlock",...
} & BaseComment
export type CommentLine = {
type: "CommentLine",...
} & BaseComment
export type Comment = CommentBlock | CommentLine;export interface SourceLocation {
start: {
line: number,
column: number,...
},
end: {
line: number,
column: number,...
},
} declare interface BaseNode {
leadingComments: $ReadOnlyArray<Comment> | null,
innerComments: $ReadOnlyArray<Comment> | null,
trailingComments: $ReadOnlyArray<Comment> | null,
start: number | null,
end: number | null,
loc: SourceLocation | null,
type: $PropertyType<Node, "type">,
extra?: {[key: string]: mixed, ...},
} export type Node = Accessor
| AnyTypeAnnotation
| ArgumentPlaceholder
| ArrayExpression
| ArrayPattern
| ArrayTypeAnnotation
| ArrowFunctionExpression
| AssignmentExpression
| AssignmentPattern
| AwaitExpression
| BigIntLiteral
| Binary
| BinaryExpression
| BindExpression
| Block
| BlockParent
| BlockStatement
| BooleanLiteral
| BooleanLiteralTypeAnnotation
| BooleanTypeAnnotation
| BreakStatement
| CallExpression
| CatchClause
| Class
| ClassAccessorProperty
| ClassBody
| ClassDeclaration
| ClassExpression
| ClassImplements
| ClassMethod
| ClassPrivateMethod
| ClassPrivateProperty
| ClassProperty
| CompletionStatement
| Conditional
| ConditionalExpression
| ContinueStatement
| DebuggerStatement
| DecimalLiteral
| Declaration
| DeclareClass
| DeclareExportAllDeclaration
| DeclareExportDeclaration
| DeclareFunction
| DeclareInterface
| DeclareModule
| DeclareModuleExports
| DeclareOpaqueType
| DeclareTypeAlias
| DeclareVariable
| DeclaredPredicate
| Decorator
| Directive
| DirectiveLiteral
| DoExpression
| DoWhileStatement
| EmptyStatement
| EmptyTypeAnnotation
| EnumBody
| EnumBooleanBody
| EnumBooleanMember
| EnumDeclaration
| EnumDefaultedMember
| EnumMember
| EnumNumberBody
| EnumNumberMember
| EnumStringBody
| EnumStringMember
| EnumSymbolBody
| ExistsTypeAnnotation
| ExportAllDeclaration
| ExportDeclaration
| ExportDefaultDeclaration
| ExportDefaultSpecifier
| ExportNamedDeclaration
| ExportNamespaceSpecifier
| ExportSpecifier
| Expression
| ExpressionStatement
| ExpressionWrapper
| File
| Flow
| FlowBaseAnnotation
| FlowDeclaration
| FlowPredicate
| FlowType
| For
| ForInStatement
| ForOfStatement
| ForStatement
| ForXStatement
| Function
| FunctionDeclaration
| FunctionExpression
| FunctionParent
| FunctionTypeAnnotation
| FunctionTypeParam
| GenericTypeAnnotation
| Identifier
| IfStatement
| Immutable
| Import
| ImportAttribute
| ImportDeclaration
| ImportDefaultSpecifier
| ImportNamespaceSpecifier
| ImportSpecifier
| IndexedAccessType
| InferredPredicate
| InterfaceDeclaration
| InterfaceExtends
| InterfaceTypeAnnotation
| InterpreterDirective
| IntersectionTypeAnnotation
| JSX
| JSXAttribute
| JSXClosingElement
| JSXClosingFragment
| JSXElement
| JSXEmptyExpression
| JSXExpressionContainer
| JSXFragment
| JSXIdentifier
| JSXMemberExpression
| JSXNamespacedName
| JSXOpeningElement
| JSXOpeningFragment
| JSXSpreadAttribute
| JSXSpreadChild
| JSXText
| LVal
| LabeledStatement
| Literal
| LogicalExpression
| Loop
| MemberExpression
| MetaProperty
| Method
| Miscellaneous
| MixedTypeAnnotation
| ModuleDeclaration
| ModuleExpression
| ModuleSpecifier
| NewExpression
| Noop
| NullLiteral
| NullLiteralTypeAnnotation
| NullableTypeAnnotation
| NumberLiteral
| NumberLiteralTypeAnnotation
| NumberTypeAnnotation
| NumericLiteral
| ObjectExpression
| ObjectMember
| ObjectMethod
| ObjectPattern
| ObjectProperty
| ObjectTypeAnnotation
| ObjectTypeCallProperty
| ObjectTypeIndexer
| ObjectTypeInternalSlot
| ObjectTypeProperty
| ObjectTypeSpreadProperty
| OpaqueType
| OptionalCallExpression
| OptionalIndexedAccessType
| OptionalMemberExpression
| ParenthesizedExpression
| Pattern
| PatternLike
| PipelineBareFunction
| PipelinePrimaryTopicReference
| PipelineTopicExpression
| Placeholder
| Private
| PrivateName
| Program
| Property
| Pureish
| QualifiedTypeIdentifier
| RecordExpression
| RegExpLiteral
| RegexLiteral
| RestElement
| RestProperty
| ReturnStatement
| Scopable
| SequenceExpression
| SpreadElement
| SpreadProperty
| Standardized
| Statement
| StaticBlock
| StringLiteral
| StringLiteralTypeAnnotation
| StringTypeAnnotation
| Super
| SwitchCase
| SwitchStatement
| SymbolTypeAnnotation
| TSAnyKeyword
| TSArrayType
| TSAsExpression
| TSBaseType
| TSBigIntKeyword
| TSBooleanKeyword
| TSCallSignatureDeclaration
| TSConditionalType
| TSConstructSignatureDeclaration
| TSConstructorType
| TSDeclareFunction
| TSDeclareMethod
| TSEntityName
| TSEnumDeclaration
| TSEnumMember
| TSExportAssignment
| TSExpressionWithTypeArguments
| TSExternalModuleReference
| TSFunctionType
| TSImportEqualsDeclaration
| TSImportType
| TSIndexSignature
| TSIndexedAccessType
| TSInferType
| TSInstantiationExpression
| TSInterfaceBody
| TSInterfaceDeclaration
| TSIntersectionType
| TSIntrinsicKeyword
| TSLiteralType
| TSMappedType
| TSMethodSignature
| TSModuleBlock
| TSModuleDeclaration
| TSNamedTupleMember
| TSNamespaceExportDeclaration
| TSNeverKeyword
| TSNonNullExpression
| TSNullKeyword
| TSNumberKeyword
| TSObjectKeyword
| TSOptionalType
| TSParameterProperty
| TSParenthesizedType
| TSPropertySignature
| TSQualifiedName
| TSRestType
| TSStringKeyword
| TSSymbolKeyword
| TSThisType
| TSTupleType
| TSType
| TSTypeAliasDeclaration
| TSTypeAnnotation
| TSTypeAssertion
| TSTypeElement
| TSTypeLiteral
| TSTypeOperator
| TSTypeParameter
| TSTypeParameterDeclaration
| TSTypeParameterInstantiation
| TSTypePredicate
| TSTypeQuery
| TSTypeReference
| TSUndefinedKeyword
| TSUnionType
| TSUnknownKeyword
| TSVoidKeyword
| TaggedTemplateExpression
| TemplateElement
| TemplateLiteral
| Terminatorless
| ThisExpression
| ThisTypeAnnotation
| ThrowStatement
| TopicReference
| TryStatement
| TupleExpression
| TupleTypeAnnotation
| TypeAlias
| TypeAnnotation
| TypeCastExpression
| TypeParameter
| TypeParameterDeclaration
| TypeParameterInstantiation
| TypeScript
| TypeofTypeAnnotation
| UnaryExpression
| UnaryLike
| UnionTypeAnnotation
| UpdateExpression
| UserWhitespacable
| V8IntrinsicIdentifier
| VariableDeclaration
| VariableDeclarator
| Variance
| VoidTypeAnnotation
| While
| WhileStatement
| WithStatement
| YieldExpression;export type ArrayExpression = {
type: "ArrayExpression",
elements: Array<null | Expression | SpreadElement>,...
} & BaseNode
export type AssignmentExpression = {
type: "AssignmentExpression",
operator: string,
left: LVal,
right: Expression,...
} & BaseNode
export type BinaryExpression = {
type: "BinaryExpression",
operator: "+"
| "-"
| "/"
| "%"
| "*"
| "**"
| "&"
| "|"
| ">>"
| ">>>"
| "<<"
| "^"
| "=="
| "==="
| "!="
| "!=="
| "in"
| "instanceof"
| ">"
| "<"
| ">="
| "<="
| "|>",
left: Expression | PrivateName,
right: Expression,...
} & BaseNode
export type InterpreterDirective = {
type: "InterpreterDirective",
value: string,...
} & BaseNode
export type Directive = {
type: "Directive",
value: DirectiveLiteral,...
} & BaseNode
export type DirectiveLiteral = {
type: "DirectiveLiteral",
value: string,...
} & BaseNode
export type BlockStatement = {
type: "BlockStatement",
body: Array<Statement>,
directives: Array<Directive>,...
} & BaseNode
export type BreakStatement = {
type: "BreakStatement",
label: Identifier | null,...
} & BaseNode
export type CallExpression = {
type: "CallExpression",
callee: Expression | Super | V8IntrinsicIdentifier,
arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>,
optional: true | false | null,
typeArguments: TypeParameterInstantiation | null,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type CatchClause = {
type: "CatchClause",
param: Identifier | ArrayPattern | ObjectPattern | null,
body: BlockStatement,...
} & BaseNode
export type ConditionalExpression = {
type: "ConditionalExpression",
test: Expression,
consequent: Expression,
alternate: Expression,...
} & BaseNode
export type ContinueStatement = {
type: "ContinueStatement",
label: Identifier | null,...
} & BaseNode
export type DebuggerStatement = {
type: "DebuggerStatement",...
} & BaseNode
export type DoWhileStatement = {
type: "DoWhileStatement",
test: Expression,
body: Statement,...
} & BaseNode
export type EmptyStatement = {
type: "EmptyStatement",...
} & BaseNode
export type ExpressionStatement = {
type: "ExpressionStatement",
expression: Expression,...
} & BaseNode
export type File = {
type: "File",
program: Program,
comments: Array<CommentBlock | CommentLine> | null,
tokens: Array<any> | null,...
} & BaseNode
export type ForInStatement = {
type: "ForInStatement",
left: VariableDeclaration | LVal,
right: Expression,
body: Statement,...
} & BaseNode
export type ForStatement = {
type: "ForStatement",
init: VariableDeclaration | Expression | null,
test: Expression | null,
update: Expression | null,
body: Statement,...
} & BaseNode
export type FunctionDeclaration = {
type: "FunctionDeclaration",
id: Identifier | null,
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement,
generator: boolean,
async: boolean,
declare: boolean | null,
predicate: DeclaredPredicate | InferredPredicate | null,
returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type FunctionExpression = {
type: "FunctionExpression",
id: Identifier | null,
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement,
generator: boolean,
async: boolean,
predicate: DeclaredPredicate | InferredPredicate | null,
returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type Identifier = {
type: "Identifier",
name: string,
decorators: Array<Decorator> | null,
optional: boolean | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,...
} & BaseNode
export type IfStatement = {
type: "IfStatement",
test: Expression,
consequent: Statement,
alternate: Statement | null,...
} & BaseNode
export type LabeledStatement = {
type: "LabeledStatement",
label: Identifier,
body: Statement,...
} & BaseNode
export type StringLiteral = {
type: "StringLiteral",
value: string,...
} & BaseNode
export type NumericLiteral = {
type: "NumericLiteral",
value: number,...
} & BaseNode
export type NullLiteral = {
type: "NullLiteral",...
} & BaseNode
export type BooleanLiteral = {
type: "BooleanLiteral",
value: boolean,...
} & BaseNode
export type RegExpLiteral = {
type: "RegExpLiteral",
pattern: string,
flags: string,...
} & BaseNode
export type LogicalExpression = {
type: "LogicalExpression",
operator: "||" | "&&" | "??",
left: Expression,
right: Expression,...
} & BaseNode
export type MemberExpression = {
type: "MemberExpression",
object: Expression | Super,
property: Expression | Identifier | PrivateName,
computed: boolean,
optional: true | false | null,...
} & BaseNode
export type NewExpression = {
type: "NewExpression",
callee: Expression | Super | V8IntrinsicIdentifier,
arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>,
optional: true | false | null,
typeArguments: TypeParameterInstantiation | null,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type Program = {
type: "Program",
body: Array<Statement>,
directives: Array<Directive>,
sourceType: "script" | "module",
interpreter: InterpreterDirective | null,
sourceFile: string,...
} & BaseNode
export type ObjectExpression = {
type: "ObjectExpression",
properties: Array<ObjectMethod | ObjectProperty | SpreadElement>,...
} & BaseNode
export type ObjectMethod = {
type: "ObjectMethod",
kind: "method" | "get" | "set",
key: Expression
| Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral,
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement,
computed: boolean,
generator: boolean,
async: boolean,
decorators: Array<Decorator> | null,
returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type ObjectProperty = {
type: "ObjectProperty",
key: Expression
| Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| DecimalLiteral
| PrivateName,
value: Expression | PatternLike,
computed: boolean,
shorthand: boolean,
decorators: Array<Decorator> | null,...
} & BaseNode
export type RestElement = {
type: "RestElement",
argument: LVal,
decorators: Array<Decorator> | null,
optional: boolean | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,...
} & BaseNode
export type ReturnStatement = {
type: "ReturnStatement",
argument: Expression | null,...
} & BaseNode
export type SequenceExpression = {
type: "SequenceExpression",
expressions: Array<Expression>,...
} & BaseNode
export type ParenthesizedExpression = {
type: "ParenthesizedExpression",
expression: Expression,...
} & BaseNode
export type SwitchCase = {
type: "SwitchCase",
test: Expression | null,
consequent: Array<Statement>,...
} & BaseNode
export type SwitchStatement = {
type: "SwitchStatement",
discriminant: Expression,
cases: Array<SwitchCase>,...
} & BaseNode
export type ThisExpression = {
type: "ThisExpression",...
} & BaseNode
export type ThrowStatement = {
type: "ThrowStatement",
argument: Expression,...
} & BaseNode
export type TryStatement = {
type: "TryStatement",
block: BlockStatement,
handler: CatchClause | null,
finalizer: BlockStatement | null,...
} & BaseNode
export type UnaryExpression = {
type: "UnaryExpression",
operator: "void"
| "throw"
| "delete"
| "!"
| "+"
| "-"
| "~"
| "typeof",
argument: Expression,
prefix: boolean,...
} & BaseNode
export type UpdateExpression = {
type: "UpdateExpression",
operator: "++" | "--",
argument: Expression,
prefix: boolean,...
} & BaseNode
export type VariableDeclaration = {
type: "VariableDeclaration",
kind: "var" | "let" | "const",
declarations: Array<VariableDeclarator>,
declare: boolean | null,...
} & BaseNode
export type VariableDeclarator = {
type: "VariableDeclarator",
id: LVal,
init: Expression | null,
definite: boolean | null,...
} & BaseNode
export type WhileStatement = {
type: "WhileStatement",
test: Expression,
body: Statement,...
} & BaseNode
export type WithStatement = {
type: "WithStatement",
object: Expression,
body: Statement,...
} & BaseNode
export type AssignmentPattern = {
type: "AssignmentPattern",
left: Identifier
| ObjectPattern
| ArrayPattern
| MemberExpression
| TSAsExpression
| TSTypeAssertion
| TSNonNullExpression,
right: Expression,
decorators: Array<Decorator> | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,...
} & BaseNode
export type ArrayPattern = {
type: "ArrayPattern",
elements: Array<null | PatternLike | LVal>,
decorators: Array<Decorator> | null,
optional: boolean | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,...
} & BaseNode
export type ArrowFunctionExpression = {
type: "ArrowFunctionExpression",
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement | Expression,
async: boolean,
expression: boolean,
generator: boolean,
predicate: DeclaredPredicate | InferredPredicate | null,
returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type ClassBody = {
type: "ClassBody",
body: Array<ClassMethod
| ClassPrivateMethod
| ClassProperty
| ClassPrivateProperty
| ClassAccessorProperty
| TSDeclareMethod
| TSIndexSignature
| StaticBlock>,...
} & BaseNode
export type ClassExpression = {
type: "ClassExpression",
id: Identifier | null,
superClass: Expression | null,
body: ClassBody,
decorators: Array<Decorator> | null,
implements: Array<TSExpressionWithTypeArguments | ClassImplements> | null,
mixins: InterfaceExtends | null,
superTypeParameters: TypeParameterInstantiation | TSTypeParameterInstantiation | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type ClassDeclaration = {
type: "ClassDeclaration",
id: Identifier,
superClass: Expression | null,
body: ClassBody,
decorators: Array<Decorator> | null,
abstract: boolean | null,
declare: boolean | null,
implements: Array<TSExpressionWithTypeArguments | ClassImplements> | null,
mixins: InterfaceExtends | null,
superTypeParameters: TypeParameterInstantiation | TSTypeParameterInstantiation | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type ExportAllDeclaration = {
type: "ExportAllDeclaration",
source: StringLiteral,
assertions: Array<ImportAttribute> | null,
exportKind: "type" | "value" | null,...
} & BaseNode
export type ExportDefaultDeclaration = {
type: "ExportDefaultDeclaration",
declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Expression,
exportKind: "value" | null,...
} & BaseNode
export type ExportNamedDeclaration = {
type: "ExportNamedDeclaration",
declaration: Declaration | null,
specifiers: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>,
source: StringLiteral | null,
assertions: Array<ImportAttribute> | null,
exportKind: "type" | "value" | null,...
} & BaseNode
export type ExportSpecifier = {
type: "ExportSpecifier",
local: Identifier,
exported: Identifier | StringLiteral,
exportKind: "type" | "value" | null,...
} & BaseNode
export type ForOfStatement = {
type: "ForOfStatement",
left: VariableDeclaration | LVal,
right: Expression,
body: Statement,
await: boolean,...
} & BaseNode
export type ImportDeclaration = {
type: "ImportDeclaration",
specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>,
source: StringLiteral,
assertions: Array<ImportAttribute> | null,
importKind: "type" | "typeof" | "value" | null,...
} & BaseNode
export type ImportDefaultSpecifier = {
type: "ImportDefaultSpecifier",
local: Identifier,...
} & BaseNode
export type ImportNamespaceSpecifier = {
type: "ImportNamespaceSpecifier",
local: Identifier,...
} & BaseNode
export type ImportSpecifier = {
type: "ImportSpecifier",
local: Identifier,
imported: Identifier | StringLiteral,
importKind: "type" | "typeof" | "value" | null,...
} & BaseNode
export type MetaProperty = {
type: "MetaProperty",
meta: Identifier,
property: Identifier,...
} & BaseNode
export type ClassMethod = {
type: "ClassMethod",
kind: "get" | "set" | "method" | "constructor",
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression,
params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
body: BlockStatement,
computed: boolean,
static: boolean,
generator: boolean,
async: boolean,
abstract: boolean | null,
access: "public" | "private" | "protected" | null,
accessibility: "public" | "private" | "protected" | null,
decorators: Array<Decorator> | null,
optional: boolean | null,
override: boolean,
returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type ObjectPattern = {
type: "ObjectPattern",
properties: Array<RestElement | ObjectProperty>,
decorators: Array<Decorator> | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,...
} & BaseNode
export type SpreadElement = {
type: "SpreadElement",
argument: Expression,...
} & BaseNode
export type Super = {
type: "Super",...
} & BaseNode
export type TaggedTemplateExpression = {
type: "TaggedTemplateExpression",
tag: Expression,
quasi: TemplateLiteral,
typeParameters: TypeParameterInstantiation | TSTypeParameterInstantiation | null,...
} & BaseNode
export type TemplateElement = {
type: "TemplateElement",
value: {
raw: string,
cooked?: string,...
},
tail: boolean,...
} & BaseNode
export type TemplateLiteral = {
type: "TemplateLiteral",
quasis: Array<TemplateElement>,
expressions: Array<Expression | TSType>,...
} & BaseNode
export type YieldExpression = {
type: "YieldExpression",
argument: Expression | null,
delegate: boolean,...
} & BaseNode
export type AwaitExpression = {
type: "AwaitExpression",
argument: Expression,...
} & BaseNode
export type Import = {
type: "Import",...
} & BaseNode
export type BigIntLiteral = {
type: "BigIntLiteral",
value: string,...
} & BaseNode
export type ExportNamespaceSpecifier = {
type: "ExportNamespaceSpecifier",
exported: Identifier,...
} & BaseNode
export type OptionalMemberExpression = {
type: "OptionalMemberExpression",
object: Expression,
property: Expression | Identifier,
computed: boolean,
optional: boolean,...
} & BaseNode
export type OptionalCallExpression = {
type: "OptionalCallExpression",
callee: Expression,
arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>,
optional: boolean,
typeArguments: TypeParameterInstantiation | null,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type ClassProperty = {
type: "ClassProperty",
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression,
value: Expression | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
decorators: Array<Decorator> | null,
computed: boolean,
static: boolean,
abstract: boolean | null,
accessibility: "public" | "private" | "protected" | null,
declare: boolean | null,
definite: boolean | null,
optional: boolean | null,
override: boolean,
readonly: boolean | null,
variance: Variance | null,...
} & BaseNode
export type ClassAccessorProperty = {
type: "ClassAccessorProperty",
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression
| PrivateName,
value: Expression | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
decorators: Array<Decorator> | null,
computed: boolean,
static: boolean,
abstract: boolean | null,
accessibility: "public" | "private" | "protected" | null,
declare: boolean | null,
definite: boolean | null,
optional: boolean | null,
override: boolean,
readonly: boolean | null,
variance: Variance | null,...
} & BaseNode
export type ClassPrivateProperty = {
type: "ClassPrivateProperty",
key: PrivateName,
value: Expression | null,
decorators: Array<Decorator> | null,
static: boolean,
definite: boolean | null,
readonly: boolean | null,
typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null,
variance: Variance | null,...
} & BaseNode
export type ClassPrivateMethod = {
type: "ClassPrivateMethod",
kind: "get" | "set" | "method",
key: PrivateName,
params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
body: BlockStatement,
static: boolean,
abstract: boolean | null,
access: "public" | "private" | "protected" | null,
accessibility: "public" | "private" | "protected" | null,
async: boolean,
computed: boolean,
decorators: Array<Decorator> | null,
generator: boolean,
optional: boolean | null,
override: boolean,
returnType: TypeAnnotation | TSTypeAnnotation | Noop | null,
typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null,...
} & BaseNode
export type PrivateName = {
type: "PrivateName",
id: Identifier,...
} & BaseNode
export type StaticBlock = {
type: "StaticBlock",
body: Array<Statement>,...
} & BaseNode
export type AnyTypeAnnotation = {
type: "AnyTypeAnnotation",...
} & BaseNode
export type ArrayTypeAnnotation = {
type: "ArrayTypeAnnotation",
elementType: FlowType,...
} & BaseNode
export type BooleanTypeAnnotation = {
type: "BooleanTypeAnnotation",...
} & BaseNode
export type BooleanLiteralTypeAnnotation = {
type: "BooleanLiteralTypeAnnotation",
value: boolean,...
} & BaseNode
export type NullLiteralTypeAnnotation = {
type: "NullLiteralTypeAnnotation",...
} & BaseNode
export type ClassImplements = {
type: "ClassImplements",
id: Identifier,
typeParameters: TypeParameterInstantiation | null,...
} & BaseNode
export type DeclareClass = {
type: "DeclareClass",
id: Identifier,
typeParameters: TypeParameterDeclaration | null,
extends: Array<InterfaceExtends> | null,
body: ObjectTypeAnnotation,
implements: Array<ClassImplements> | null,
mixins: Array<InterfaceExtends> | null,...
} & BaseNode
export type DeclareFunction = {
type: "DeclareFunction",
id: Identifier,
predicate: DeclaredPredicate | null,...
} & BaseNode
export type DeclareInterface = {
type: "DeclareInterface",
id: Identifier,
typeParameters: TypeParameterDeclaration | null,
extends: Array<InterfaceExtends> | null,
body: ObjectTypeAnnotation,
implements: Array<ClassImplements> | null,
mixins: Array<InterfaceExtends> | null,...
} & BaseNode
export type DeclareModule = {
type: "DeclareModule",
id: Identifier | StringLiteral,
body: BlockStatement,
kind: "CommonJS" | "ES" | null,...
} & BaseNode
export type DeclareModuleExports = {
type: "DeclareModuleExports",
typeAnnotation: TypeAnnotation,...
} & BaseNode
export type DeclareTypeAlias = {
type: "DeclareTypeAlias",
id: Identifier,
typeParameters: TypeParameterDeclaration | null,
right: FlowType,...
} & BaseNode
export type DeclareOpaqueType = {
type: "DeclareOpaqueType",
id: Identifier,
typeParameters: TypeParameterDeclaration | null,
supertype: FlowType | null,
impltype: FlowType | null,...
} & BaseNode
export type DeclareVariable = {
type: "DeclareVariable",
id: Identifier,...
} & BaseNode
export type DeclareExportDeclaration = {
type: "DeclareExportDeclaration",
declaration: Flow | null,
specifiers: Array<ExportSpecifier | ExportNamespaceSpecifier> | null,
source: StringLiteral | null,
default: boolean | null,...
} & BaseNode
export type DeclareExportAllDeclaration = {
type: "DeclareExportAllDeclaration",
source: StringLiteral,
exportKind: "type" | "value" | null,...
} & BaseNode
export type DeclaredPredicate = {
type: "DeclaredPredicate",
value: Flow,...
} & BaseNode
export type ExistsTypeAnnotation = {
type: "ExistsTypeAnnotation",...
} & BaseNode
export type FunctionTypeAnnotation = {
type: "FunctionTypeAnnotation",
typeParameters: TypeParameterDeclaration | null,
params: Array<FunctionTypeParam>,
rest: FunctionTypeParam | null,
returnType: FlowType,
this: FunctionTypeParam | null,...
} & BaseNode
export type FunctionTypeParam = {
type: "FunctionTypeParam",
name: Identifier | null,
typeAnnotation: FlowType,
optional: boolean | null,...
} & BaseNode
export type GenericTypeAnnotation = {
type: "GenericTypeAnnotation",
id: Identifier | QualifiedTypeIdentifier,
typeParameters: TypeParameterInstantiation | null,...
} & BaseNode
export type InferredPredicate = {
type: "InferredPredicate",...
} & BaseNode
export type InterfaceExtends = {
type: "InterfaceExtends",
id: Identifier | QualifiedTypeIdentifier,
typeParameters: TypeParameterInstantiation | null,...
} & BaseNode
export type InterfaceDeclaration = {
type: "InterfaceDeclaration",
id: Identifier,
typeParameters: TypeParameterDeclaration | null,
extends: Array<InterfaceExtends> | null,
body: ObjectTypeAnnotation,
implements: Array<ClassImplements> | null,
mixins: Array<InterfaceExtends> | null,...
} & BaseNode
export type InterfaceTypeAnnotation = {
type: "InterfaceTypeAnnotation",
extends: Array<InterfaceExtends> | null,
body: ObjectTypeAnnotation,...
} & BaseNode
export type IntersectionTypeAnnotation = {
type: "IntersectionTypeAnnotation",
types: Array<FlowType>,...
} & BaseNode
export type MixedTypeAnnotation = {
type: "MixedTypeAnnotation",...
} & BaseNode
export type EmptyTypeAnnotation = {
type: "EmptyTypeAnnotation",...
} & BaseNode
export type NullableTypeAnnotation = {
type: "NullableTypeAnnotation",
typeAnnotation: FlowType,...
} & BaseNode
export type NumberLiteralTypeAnnotation = {
type: "NumberLiteralTypeAnnotation",
value: number,...
} & BaseNode
export type NumberTypeAnnotation = {
type: "NumberTypeAnnotation",...
} & BaseNode
export type ObjectTypeAnnotation = {
type: "ObjectTypeAnnotation",
properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>,
indexers: Array<ObjectTypeIndexer>,
callProperties: Array<ObjectTypeCallProperty>,
internalSlots: Array<ObjectTypeInternalSlot>,
exact: boolean,
inexact: boolean | null,...
} & BaseNode
export type ObjectTypeInternalSlot = {
type: "ObjectTypeInternalSlot",
id: Identifier,
value: FlowType,
optional: boolean,
static: boolean,
method: boolean,...
} & BaseNode
export type ObjectTypeCallProperty = {
type: "ObjectTypeCallProperty",
value: FlowType,
static: boolean,...
} & BaseNode
export type ObjectTypeIndexer = {
type: "ObjectTypeIndexer",
id: Identifier | null,
key: FlowType,
value: FlowType,
variance: Variance | null,
static: boolean,...
} & BaseNode
export type ObjectTypeProperty = {
type: "ObjectTypeProperty",
key: Identifier | StringLiteral,
value: FlowType,
variance: Variance | null,
kind: "init" | "get" | "set",
method: boolean,
optional: boolean,
proto: boolean,
static: boolean,...
} & BaseNode
export type ObjectTypeSpreadProperty = {
type: "ObjectTypeSpreadProperty",
argument: FlowType,...
} & BaseNode
export type OpaqueType = {
type: "OpaqueType",
id: Identifier,
typeParameters: TypeParameterDeclaration | null,
supertype: FlowType | null,
impltype: FlowType,...
} & BaseNode
export type QualifiedTypeIdentifier = {
type: "QualifiedTypeIdentifier",
id: Identifier,
qualification: Identifier | QualifiedTypeIdentifier,...
} & BaseNode
export type StringLiteralTypeAnnotation = {
type: "StringLiteralTypeAnnotation",
value: string,...
} & BaseNode
export type StringTypeAnnotation = {
type: "StringTypeAnnotation",...
} & BaseNode
export type SymbolTypeAnnotation = {
type: "SymbolTypeAnnotation",...
} & BaseNode
export type ThisTypeAnnotation = {
type: "ThisTypeAnnotation",...
} & BaseNode
export type TupleTypeAnnotation = {
type: "TupleTypeAnnotation",
types: Array<FlowType>,...
} & BaseNode
export type TypeofTypeAnnotation = {
type: "TypeofTypeAnnotation",
argument: FlowType,...
} & BaseNode
export type TypeAlias = {
type: "TypeAlias",
id: Identifier,
typeParameters: TypeParameterDeclaration | null,
right: FlowType,...
} & BaseNode
export type TypeAnnotation = {
type: "TypeAnnotation",
typeAnnotation: FlowType,...
} & BaseNode
export type TypeCastExpression = {
type: "TypeCastExpression",
expression: Expression,
typeAnnotation: TypeAnnotation,...
} & BaseNode
export type TypeParameter = {
type: "TypeParameter",
bound: TypeAnnotation | null,
default: FlowType | null,
variance: Variance | null,
name: string,...
} & BaseNode
export type TypeParameterDeclaration = {
type: "TypeParameterDeclaration",
params: Array<TypeParameter>,...
} & BaseNode
export type TypeParameterInstantiation = {
type: "TypeParameterInstantiation",
params: Array<FlowType>,...
} & BaseNode
export type UnionTypeAnnotation = {
type: "UnionTypeAnnotation",
types: Array<FlowType>,...
} & BaseNode
export type Variance = {
type: "Variance",
kind: "minus" | "plus",...
} & BaseNode
export type VoidTypeAnnotation = {
type: "VoidTypeAnnotation",...
} & BaseNode
export type EnumDeclaration = {
type: "EnumDeclaration",
id: Identifier,
body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody,...
} & BaseNode
export type EnumBooleanBody = {
type: "EnumBooleanBody",
members: Array<EnumBooleanMember>,
explicitType: boolean,
hasUnknownMembers: boolean,...
} & BaseNode
export type EnumNumberBody = {
type: "EnumNumberBody",
members: Array<EnumNumberMember>,
explicitType: boolean,
hasUnknownMembers: boolean,...
} & BaseNode
export type EnumStringBody = {
type: "EnumStringBody",
members: Array<EnumStringMember | EnumDefaultedMember>,
explicitType: boolean,
hasUnknownMembers: boolean,...
} & BaseNode
export type EnumSymbolBody = {
type: "EnumSymbolBody",
members: Array<EnumDefaultedMember>,
hasUnknownMembers: boolean,...
} & BaseNode
export type EnumBooleanMember = {
type: "EnumBooleanMember",
id: Identifier,
init: BooleanLiteral,...
} & BaseNode
export type EnumNumberMember = {
type: "EnumNumberMember",
id: Identifier,
init: NumericLiteral,...
} & BaseNode
export type EnumStringMember = {
type: "EnumStringMember",
id: Identifier,
init: StringLiteral,...
} & BaseNode
export type EnumDefaultedMember = {
type: "EnumDefaultedMember",
id: Identifier,...
} & BaseNode
export type IndexedAccessType = {
type: "IndexedAccessType",
objectType: FlowType,
indexType: FlowType,...
} & BaseNode
export type OptionalIndexedAccessType = {
type: "OptionalIndexedAccessType",
objectType: FlowType,
indexType: FlowType,
optional: boolean,...
} & BaseNode
export type JSXAttribute = {
type: "JSXAttribute",
name: JSXIdentifier | JSXNamespacedName,
value: JSXElement
| JSXFragment
| StringLiteral
| JSXExpressionContainer
| null,...
} & BaseNode
export type JSXClosingElement = {
type: "JSXClosingElement",
name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,...
} & BaseNode
export type JSXElement = {
type: "JSXElement",
openingElement: JSXOpeningElement,
closingElement: JSXClosingElement | null,
children: Array<JSXText
| JSXExpressionContainer
| JSXSpreadChild
| JSXElement
| JSXFragment>,
selfClosing: boolean | null,...
} & BaseNode
export type JSXEmptyExpression = {
type: "JSXEmptyExpression",...
} & BaseNode
export type JSXExpressionContainer = {
type: "JSXExpressionContainer",
expression: Expression | JSXEmptyExpression,...
} & BaseNode
export type JSXSpreadChild = {
type: "JSXSpreadChild",
expression: Expression,...
} & BaseNode
export type JSXIdentifier = {
type: "JSXIdentifier",
name: string,...
} & BaseNode
export type JSXMemberExpression = {
type: "JSXMemberExpression",
object: JSXMemberExpression | JSXIdentifier,
property: JSXIdentifier,...
} & BaseNode
export type JSXNamespacedName = {
type: "JSXNamespacedName",
namespace: JSXIdentifier,
name: JSXIdentifier,...
} & BaseNode
export type JSXOpeningElement = {
type: "JSXOpeningElement",
name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
attributes: Array<JSXAttribute | JSXSpreadAttribute>,
selfClosing: boolean,
typeParameters: TypeParameterInstantiation | TSTypeParameterInstantiation | null,...
} & BaseNode
export type JSXSpreadAttribute = {
type: "JSXSpreadAttribute",
argument: Expression,...
} & BaseNode
export type JSXText = {
type: "JSXText",
value: string,...
} & BaseNode
export type JSXFragment = {
type: "JSXFragment",
openingFragment: JSXOpeningFragment,
closingFragment: JSXClosingFragment,
children: Array<JSXText
| JSXExpressionContainer
| JSXSpreadChild
| JSXElement
| JSXFragment>,...
} & BaseNode
export type JSXOpeningFragment = {
type: "JSXOpeningFragment",...
} & BaseNode
export type JSXClosingFragment = {
type: "JSXClosingFragment",...
} & BaseNode
export type Noop = {
type: "Noop",...
} & BaseNode
export type Placeholder = {
type: "Placeholder",
expectedNode: "Identifier"
| "StringLiteral"
| "Expression"
| "Statement"
| "Declaration"
| "BlockStatement"
| "ClassBody"
| "Pattern",
name: Identifier,...
} & BaseNode
export type V8IntrinsicIdentifier = {
type: "V8IntrinsicIdentifier",
name: string,...
} & BaseNode
export type ArgumentPlaceholder = {
type: "ArgumentPlaceholder",...
} & BaseNode
export type BindExpression = {
type: "BindExpression",
object: Expression,
callee: Expression,...
} & BaseNode
export type ImportAttribute = {
type: "ImportAttribute",
key: Identifier | StringLiteral,
value: StringLiteral,...
} & BaseNode
export type Decorator = {
type: "Decorator",
expression: Expression,...
} & BaseNode
export type DoExpression = {
type: "DoExpression",
body: BlockStatement,
async: boolean,...
} & BaseNode
export type ExportDefaultSpecifier = {
type: "ExportDefaultSpecifier",
exported: Identifier,...
} & BaseNode
export type RecordExpression = {
type: "RecordExpression",
properties: Array<ObjectProperty | SpreadElement>,...
} & BaseNode
export type TupleExpression = {
type: "TupleExpression",
elements: Array<Expression | SpreadElement>,...
} & BaseNode
export type DecimalLiteral = {
type: "DecimalLiteral",
value: string,...
} & BaseNode
export type ModuleExpression = {
type: "ModuleExpression",
body: Program,...
} & BaseNode
export type TopicReference = {
type: "TopicReference",...
} & BaseNode
export type PipelineTopicExpression = {
type: "PipelineTopicExpression",
expression: Expression,...
} & BaseNode
export type PipelineBareFunction = {
type: "PipelineBareFunction",
callee: Expression,...
} & BaseNode
export type PipelinePrimaryTopicReference = {
type: "PipelinePrimaryTopicReference",...
} & BaseNode
export type TSParameterProperty = {
type: "TSParameterProperty",
parameter: Identifier | AssignmentPattern,
accessibility: "public" | "private" | "protected" | null,
decorators: Array<Decorator> | null,
override: boolean | null,
readonly: boolean | null,...
} & BaseNode
export type TSDeclareFunction = {
type: "TSDeclareFunction",
id: Identifier | null,
typeParameters: TSTypeParameterDeclaration | Noop | null,
params: Array<Identifier | Pattern | RestElement>,
returnType: TSTypeAnnotation | Noop | null,
async: boolean,
declare: boolean | null,
generator: boolean,...
} & BaseNode
export type TSDeclareMethod = {
type: "TSDeclareMethod",
decorators: Array<Decorator> | null,
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression,
typeParameters: TSTypeParameterDeclaration | Noop | null,
params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
returnType: TSTypeAnnotation | Noop | null,
abstract: boolean | null,
access: "public" | "private" | "protected" | null,
accessibility: "public" | "private" | "protected" | null,
async: boolean,
computed: boolean,
generator: boolean,
kind: "get" | "set" | "method" | "constructor",
optional: boolean | null,
override: boolean,
static: boolean,...
} & BaseNode
export type TSQualifiedName = {
type: "TSQualifiedName",
left: TSEntityName,
right: Identifier,...
} & BaseNode
export type TSCallSignatureDeclaration = {
type: "TSCallSignatureDeclaration",
typeParameters: TSTypeParameterDeclaration | null,
parameters: Array<Identifier | RestElement>,
typeAnnotation: TSTypeAnnotation | null,...
} & BaseNode
export type TSConstructSignatureDeclaration = {
type: "TSConstructSignatureDeclaration",
typeParameters: TSTypeParameterDeclaration | null,
parameters: Array<Identifier | RestElement>,
typeAnnotation: TSTypeAnnotation | null,...
} & BaseNode
export type TSPropertySignature = {
type: "TSPropertySignature",
key: Expression,
typeAnnotation: TSTypeAnnotation | null,
initializer: Expression | null,
computed: boolean,
kind: "get" | "set",
optional: boolean | null,
readonly: boolean | null,...
} & BaseNode
export type TSMethodSignature = {
type: "TSMethodSignature",
key: Expression,
typeParameters: TSTypeParameterDeclaration | null,
parameters: Array<Identifier | RestElement>,
typeAnnotation: TSTypeAnnotation | null,
computed: boolean,
kind: "method" | "get" | "set",
optional: boolean | null,...
} & BaseNode
export type TSIndexSignature = {
type: "TSIndexSignature",
parameters: Array<Identifier>,
typeAnnotation: TSTypeAnnotation | null,
readonly: boolean | null,
static: boolean | null,...
} & BaseNode
export type TSAnyKeyword = {
type: "TSAnyKeyword",...
} & BaseNode
export type TSBooleanKeyword = {
type: "TSBooleanKeyword",...
} & BaseNode
export type TSBigIntKeyword = {
type: "TSBigIntKeyword",...
} & BaseNode
export type TSIntrinsicKeyword = {
type: "TSIntrinsicKeyword",...
} & BaseNode
export type TSNeverKeyword = {
type: "TSNeverKeyword",...
} & BaseNode
export type TSNullKeyword = {
type: "TSNullKeyword",...
} & BaseNode
export type TSNumberKeyword = {
type: "TSNumberKeyword",...
} & BaseNode
export type TSObjectKeyword = {
type: "TSObjectKeyword",...
} & BaseNode
export type TSStringKeyword = {
type: "TSStringKeyword",...
} & BaseNode
export type TSSymbolKeyword = {
type: "TSSymbolKeyword",...
} & BaseNode
export type TSUndefinedKeyword = {
type: "TSUndefinedKeyword",...
} & BaseNode
export type TSUnknownKeyword = {
type: "TSUnknownKeyword",...
} & BaseNode
export type TSVoidKeyword = {
type: "TSVoidKeyword",...
} & BaseNode
export type TSThisType = {
type: "TSThisType",...
} & BaseNode
export type TSFunctionType = {
type: "TSFunctionType",
typeParameters: TSTypeParameterDeclaration | null,
parameters: Array<Identifier | RestElement>,
typeAnnotation: TSTypeAnnotation | null,...
} & BaseNode
export type TSConstructorType = {
type: "TSConstructorType",
typeParameters: TSTypeParameterDeclaration | null,
parameters: Array<Identifier | RestElement>,
typeAnnotation: TSTypeAnnotation | null,
abstract: boolean | null,...
} & BaseNode
export type TSTypeReference = {
type: "TSTypeReference",
typeName: TSEntityName,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type TSTypePredicate = {
type: "TSTypePredicate",
parameterName: Identifier | TSThisType,
typeAnnotation: TSTypeAnnotation | null,
asserts: boolean | null,...
} & BaseNode
export type TSTypeQuery = {
type: "TSTypeQuery",
exprName: TSEntityName | TSImportType,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type TSTypeLiteral = {
type: "TSTypeLiteral",
members: Array<TSTypeElement>,...
} & BaseNode
export type TSArrayType = {
type: "TSArrayType",
elementType: TSType,...
} & BaseNode
export type TSTupleType = {
type: "TSTupleType",
elementTypes: Array<TSType | TSNamedTupleMember>,...
} & BaseNode
export type TSOptionalType = {
type: "TSOptionalType",
typeAnnotation: TSType,...
} & BaseNode
export type TSRestType = {
type: "TSRestType",
typeAnnotation: TSType,...
} & BaseNode
export type TSNamedTupleMember = {
type: "TSNamedTupleMember",
label: Identifier,
elementType: TSType,
optional: boolean,...
} & BaseNode
export type TSUnionType = {
type: "TSUnionType",
types: Array<TSType>,...
} & BaseNode
export type TSIntersectionType = {
type: "TSIntersectionType",
types: Array<TSType>,...
} & BaseNode
export type TSConditionalType = {
type: "TSConditionalType",
checkType: TSType,
extendsType: TSType,
trueType: TSType,
falseType: TSType,...
} & BaseNode
export type TSInferType = {
type: "TSInferType",
typeParameter: TSTypeParameter,...
} & BaseNode
export type TSParenthesizedType = {
type: "TSParenthesizedType",
typeAnnotation: TSType,...
} & BaseNode
export type TSTypeOperator = {
type: "TSTypeOperator",
typeAnnotation: TSType,
operator: string,...
} & BaseNode
export type TSIndexedAccessType = {
type: "TSIndexedAccessType",
objectType: TSType,
indexType: TSType,...
} & BaseNode
export type TSMappedType = {
type: "TSMappedType",
typeParameter: TSTypeParameter,
typeAnnotation: TSType | null,
nameType: TSType | null,
optional: true
| false
| "+"
| "-"
| null,
readonly: true
| false
| "+"
| "-"
| null,...
} & BaseNode
export type TSLiteralType = {
type: "TSLiteralType",
literal: NumericLiteral
| StringLiteral
| BooleanLiteral
| BigIntLiteral
| TemplateLiteral
| UnaryExpression,...
} & BaseNode
export type TSExpressionWithTypeArguments = {
type: "TSExpressionWithTypeArguments",
expression: TSEntityName,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type TSInterfaceDeclaration = {
type: "TSInterfaceDeclaration",
id: Identifier,
typeParameters: TSTypeParameterDeclaration | null,
extends: Array<TSExpressionWithTypeArguments> | null,
body: TSInterfaceBody,
declare: boolean | null,...
} & BaseNode
export type TSInterfaceBody = {
type: "TSInterfaceBody",
body: Array<TSTypeElement>,...
} & BaseNode
export type TSTypeAliasDeclaration = {
type: "TSTypeAliasDeclaration",
id: Identifier,
typeParameters: TSTypeParameterDeclaration | null,
typeAnnotation: TSType,
declare: boolean | null,...
} & BaseNode
export type TSInstantiationExpression = {
type: "TSInstantiationExpression",
expression: Expression,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type TSAsExpression = {
type: "TSAsExpression",
expression: Expression,
typeAnnotation: TSType,...
} & BaseNode
export type TSTypeAssertion = {
type: "TSTypeAssertion",
typeAnnotation: TSType,
expression: Expression,...
} & BaseNode
export type TSEnumDeclaration = {
type: "TSEnumDeclaration",
id: Identifier,
members: Array<TSEnumMember>,
const: boolean | null,
declare: boolean | null,
initializer: Expression | null,...
} & BaseNode
export type TSEnumMember = {
type: "TSEnumMember",
id: Identifier | StringLiteral,
initializer: Expression | null,...
} & BaseNode
export type TSModuleDeclaration = {
type: "TSModuleDeclaration",
id: Identifier | StringLiteral,
body: TSModuleBlock | TSModuleDeclaration,
declare: boolean | null,
global: boolean | null,...
} & BaseNode
export type TSModuleBlock = {
type: "TSModuleBlock",
body: Array<Statement>,...
} & BaseNode
export type TSImportType = {
type: "TSImportType",
argument: StringLiteral,
qualifier: TSEntityName | null,
typeParameters: TSTypeParameterInstantiation | null,...
} & BaseNode
export type TSImportEqualsDeclaration = {
type: "TSImportEqualsDeclaration",
id: Identifier,
moduleReference: TSEntityName | TSExternalModuleReference,
importKind: "type" | "value" | null,
isExport: boolean,...
} & BaseNode
export type TSExternalModuleReference = {
type: "TSExternalModuleReference",
expression: StringLiteral,...
} & BaseNode
export type TSNonNullExpression = {
type: "TSNonNullExpression",
expression: Expression,...
} & BaseNode
export type TSExportAssignment = {
type: "TSExportAssignment",
expression: Expression,...
} & BaseNode
export type TSNamespaceExportDeclaration = {
type: "TSNamespaceExportDeclaration",
id: Identifier,...
} & BaseNode
export type TSTypeAnnotation = {
type: "TSTypeAnnotation",
typeAnnotation: TSType,...
} & BaseNode
export type TSTypeParameterInstantiation = {
type: "TSTypeParameterInstantiation",
params: Array<TSType>,...
} & BaseNode
export type TSTypeParameterDeclaration = {
type: "TSTypeParameterDeclaration",
params: Array<TSTypeParameter>,...
} & BaseNode
export type TSTypeParameter = {
type: "TSTypeParameter",
constraint: TSType | null,
default: TSType | null,
name: string,
in: boolean | null,
out: boolean | null,...
} & BaseNode

/**
 * @deprecated Use `NumericLiteral`
 */
export type NumberLiteral = NumericLiteral;
/**
 * @deprecated Use `RegExpLiteral`
 */
export type RegexLiteral = RegExpLiteral;
/**
 * @deprecated Use `RestElement`
 */
export type RestProperty = RestElement;
/**
 * @deprecated Use `SpreadElement`
 */
export type SpreadProperty = SpreadElement;export type Standardized = ArrayExpression
| AssignmentExpression
| BinaryExpression
| InterpreterDirective
| Directive
| DirectiveLiteral
| BlockStatement
| BreakStatement
| CallExpression
| CatchClause
| ConditionalExpression
| ContinueStatement
| DebuggerStatement
| DoWhileStatement
| EmptyStatement
| ExpressionStatement
| File
| ForInStatement
| ForStatement
| FunctionDeclaration
| FunctionExpression
| Identifier
| IfStatement
| LabeledStatement
| StringLiteral
| NumericLiteral
| NullLiteral
| BooleanLiteral
| RegExpLiteral
| LogicalExpression
| MemberExpression
| NewExpression
| Program
| ObjectExpression
| ObjectMethod
| ObjectProperty
| RestElement
| ReturnStatement
| SequenceExpression
| ParenthesizedExpression
| SwitchCase
| SwitchStatement
| ThisExpression
| ThrowStatement
| TryStatement
| UnaryExpression
| UpdateExpression
| VariableDeclaration
| VariableDeclarator
| WhileStatement
| WithStatement
| AssignmentPattern
| ArrayPattern
| ArrowFunctionExpression
| ClassBody
| ClassExpression
| ClassDeclaration
| ExportAllDeclaration
| ExportDefaultDeclaration
| ExportNamedDeclaration
| ExportSpecifier
| ForOfStatement
| ImportDeclaration
| ImportDefaultSpecifier
| ImportNamespaceSpecifier
| ImportSpecifier
| MetaProperty
| ClassMethod
| ObjectPattern
| SpreadElement
| Super
| TaggedTemplateExpression
| TemplateElement
| TemplateLiteral
| YieldExpression
| AwaitExpression
| Import
| BigIntLiteral
| ExportNamespaceSpecifier
| OptionalMemberExpression
| OptionalCallExpression
| ClassProperty
| ClassAccessorProperty
| ClassPrivateProperty
| ClassPrivateMethod
| PrivateName
| StaticBlock;export type Expression = ArrayExpression
| AssignmentExpression
| BinaryExpression
| CallExpression
| ConditionalExpression
| FunctionExpression
| Identifier
| StringLiteral
| NumericLiteral
| NullLiteral
| BooleanLiteral
| RegExpLiteral
| LogicalExpression
| MemberExpression
| NewExpression
| ObjectExpression
| SequenceExpression
| ParenthesizedExpression
| ThisExpression
| UnaryExpression
| UpdateExpression
| ArrowFunctionExpression
| ClassExpression
| MetaProperty
| Super
| TaggedTemplateExpression
| TemplateLiteral
| YieldExpression
| AwaitExpression
| Import
| BigIntLiteral
| OptionalMemberExpression
| OptionalCallExpression
| TypeCastExpression
| JSXElement
| JSXFragment
| BindExpression
| DoExpression
| RecordExpression
| TupleExpression
| DecimalLiteral
| ModuleExpression
| TopicReference
| PipelineTopicExpression
| PipelineBareFunction
| PipelinePrimaryTopicReference
| TSInstantiationExpression
| TSAsExpression
| TSTypeAssertion
| TSNonNullExpression;export type Binary = BinaryExpression | LogicalExpression;export type Scopable = BlockStatement
| CatchClause
| DoWhileStatement
| ForInStatement
| ForStatement
| FunctionDeclaration
| FunctionExpression
| Program
| ObjectMethod
| SwitchStatement
| WhileStatement
| ArrowFunctionExpression
| ClassExpression
| ClassDeclaration
| ForOfStatement
| ClassMethod
| ClassPrivateMethod
| StaticBlock
| TSModuleBlock;export type BlockParent = BlockStatement
| CatchClause
| DoWhileStatement
| ForInStatement
| ForStatement
| FunctionDeclaration
| FunctionExpression
| Program
| ObjectMethod
| SwitchStatement
| WhileStatement
| ArrowFunctionExpression
| ForOfStatement
| ClassMethod
| ClassPrivateMethod
| StaticBlock
| TSModuleBlock;export type Block = BlockStatement | Program | TSModuleBlock;export type Statement = BlockStatement
| BreakStatement
| ContinueStatement
| DebuggerStatement
| DoWhileStatement
| EmptyStatement
| ExpressionStatement
| ForInStatement
| ForStatement
| FunctionDeclaration
| IfStatement
| LabeledStatement
| ReturnStatement
| SwitchStatement
| ThrowStatement
| TryStatement
| VariableDeclaration
| WhileStatement
| WithStatement
| ClassDeclaration
| ExportAllDeclaration
| ExportDefaultDeclaration
| ExportNamedDeclaration
| ForOfStatement
| ImportDeclaration
| DeclareClass
| DeclareFunction
| DeclareInterface
| DeclareModule
| DeclareModuleExports
| DeclareTypeAlias
| DeclareOpaqueType
| DeclareVariable
| DeclareExportDeclaration
| DeclareExportAllDeclaration
| InterfaceDeclaration
| OpaqueType
| TypeAlias
| EnumDeclaration
| TSDeclareFunction
| TSInterfaceDeclaration
| TSTypeAliasDeclaration
| TSEnumDeclaration
| TSModuleDeclaration
| TSImportEqualsDeclaration
| TSExportAssignment
| TSNamespaceExportDeclaration;export type Terminatorless = BreakStatement
| ContinueStatement
| ReturnStatement
| ThrowStatement
| YieldExpression
| AwaitExpression;export type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement;export type Conditional = ConditionalExpression | IfStatement;export type Loop = DoWhileStatement
| ForInStatement
| ForStatement
| WhileStatement
| ForOfStatement;export type While = DoWhileStatement | WhileStatement;export type ExpressionWrapper = ExpressionStatement | ParenthesizedExpression | TypeCastExpression;export type For = ForInStatement | ForStatement | ForOfStatement;export type ForXStatement = ForInStatement | ForOfStatement;export type Function = FunctionDeclaration
| FunctionExpression
| ObjectMethod
| ArrowFunctionExpression
| ClassMethod
| ClassPrivateMethod;export type FunctionParent = FunctionDeclaration
| FunctionExpression
| ObjectMethod
| ArrowFunctionExpression
| ClassMethod
| ClassPrivateMethod
| StaticBlock;export type Pureish = FunctionDeclaration
| FunctionExpression
| StringLiteral
| NumericLiteral
| NullLiteral
| BooleanLiteral
| RegExpLiteral
| ArrowFunctionExpression
| BigIntLiteral
| DecimalLiteral;export type Declaration = FunctionDeclaration
| VariableDeclaration
| ClassDeclaration
| ExportAllDeclaration
| ExportDefaultDeclaration
| ExportNamedDeclaration
| ImportDeclaration
| DeclareClass
| DeclareFunction
| DeclareInterface
| DeclareModule
| DeclareModuleExports
| DeclareTypeAlias
| DeclareOpaqueType
| DeclareVariable
| DeclareExportDeclaration
| DeclareExportAllDeclaration
| InterfaceDeclaration
| OpaqueType
| TypeAlias
| EnumDeclaration
| TSDeclareFunction
| TSInterfaceDeclaration
| TSTypeAliasDeclaration
| TSEnumDeclaration
| TSModuleDeclaration;export type PatternLike = Identifier
| RestElement
| AssignmentPattern
| ArrayPattern
| ObjectPattern
| TSAsExpression
| TSTypeAssertion
| TSNonNullExpression;export type LVal = Identifier
| MemberExpression
| RestElement
| AssignmentPattern
| ArrayPattern
| ObjectPattern
| TSParameterProperty
| TSAsExpression
| TSTypeAssertion
| TSNonNullExpression;export type TSEntityName = Identifier | TSQualifiedName;export type Literal = StringLiteral
| NumericLiteral
| NullLiteral
| BooleanLiteral
| RegExpLiteral
| TemplateLiteral
| BigIntLiteral
| DecimalLiteral;export type Immutable = StringLiteral
| NumericLiteral
| NullLiteral
| BooleanLiteral
| BigIntLiteral
| JSXAttribute
| JSXClosingElement
| JSXElement
| JSXExpressionContainer
| JSXSpreadChild
| JSXOpeningElement
| JSXText
| JSXFragment
| JSXOpeningFragment
| JSXClosingFragment
| DecimalLiteral;export type UserWhitespacable = ObjectMethod
| ObjectProperty
| ObjectTypeInternalSlot
| ObjectTypeCallProperty
| ObjectTypeIndexer
| ObjectTypeProperty
| ObjectTypeSpreadProperty;export type Method = ObjectMethod | ClassMethod | ClassPrivateMethod;export type ObjectMember = ObjectMethod | ObjectProperty;export type Property = ObjectProperty | ClassProperty | ClassAccessorProperty | ClassPrivateProperty;export type UnaryLike = UnaryExpression | SpreadElement;export type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;export type Class = ClassExpression | ClassDeclaration;export type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;export type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;export type ModuleSpecifier = ExportSpecifier
| ImportDefaultSpecifier
| ImportNamespaceSpecifier
| ImportSpecifier
| ExportNamespaceSpecifier
| ExportDefaultSpecifier;export type Accessor = ClassAccessorProperty;export type Private = ClassPrivateProperty | ClassPrivateMethod | PrivateName;export type Flow = AnyTypeAnnotation
| ArrayTypeAnnotation
| BooleanTypeAnnotation
| BooleanLiteralTypeAnnotation
| NullLiteralTypeAnnotation
| ClassImplements
| DeclareClass
| DeclareFunction
| DeclareInterface
| DeclareModule
| DeclareModuleExports
| DeclareTypeAlias
| DeclareOpaqueType
| DeclareVariable
| DeclareExportDeclaration
| DeclareExportAllDeclaration
| DeclaredPredicate
| ExistsTypeAnnotation
| FunctionTypeAnnotation
| FunctionTypeParam
| GenericTypeAnnotation
| InferredPredicate
| InterfaceExtends
| InterfaceDeclaration
| InterfaceTypeAnnotation
| IntersectionTypeAnnotation
| MixedTypeAnnotation
| EmptyTypeAnnotation
| NullableTypeAnnotation
| NumberLiteralTypeAnnotation
| NumberTypeAnnotation
| ObjectTypeAnnotation
| ObjectTypeInternalSlot
| ObjectTypeCallProperty
| ObjectTypeIndexer
| ObjectTypeProperty
| ObjectTypeSpreadProperty
| OpaqueType
| QualifiedTypeIdentifier
| StringLiteralTypeAnnotation
| StringTypeAnnotation
| SymbolTypeAnnotation
| ThisTypeAnnotation
| TupleTypeAnnotation
| TypeofTypeAnnotation
| TypeAlias
| TypeAnnotation
| TypeCastExpression
| TypeParameter
| TypeParameterDeclaration
| TypeParameterInstantiation
| UnionTypeAnnotation
| Variance
| VoidTypeAnnotation
| EnumDeclaration
| EnumBooleanBody
| EnumNumberBody
| EnumStringBody
| EnumSymbolBody
| EnumBooleanMember
| EnumNumberMember
| EnumStringMember
| EnumDefaultedMember
| IndexedAccessType
| OptionalIndexedAccessType;export type FlowType = AnyTypeAnnotation
| ArrayTypeAnnotation
| BooleanTypeAnnotation
| BooleanLiteralTypeAnnotation
| NullLiteralTypeAnnotation
| ExistsTypeAnnotation
| FunctionTypeAnnotation
| GenericTypeAnnotation
| InterfaceTypeAnnotation
| IntersectionTypeAnnotation
| MixedTypeAnnotation
| EmptyTypeAnnotation
| NullableTypeAnnotation
| NumberLiteralTypeAnnotation
| NumberTypeAnnotation
| ObjectTypeAnnotation
| StringLiteralTypeAnnotation
| StringTypeAnnotation
| SymbolTypeAnnotation
| ThisTypeAnnotation
| TupleTypeAnnotation
| TypeofTypeAnnotation
| UnionTypeAnnotation
| VoidTypeAnnotation
| IndexedAccessType
| OptionalIndexedAccessType;export type FlowBaseAnnotation = AnyTypeAnnotation
| BooleanTypeAnnotation
| NullLiteralTypeAnnotation
| MixedTypeAnnotation
| EmptyTypeAnnotation
| NumberTypeAnnotation
| StringTypeAnnotation
| SymbolTypeAnnotation
| ThisTypeAnnotation
| VoidTypeAnnotation;export type FlowDeclaration = DeclareClass
| DeclareFunction
| DeclareInterface
| DeclareModule
| DeclareModuleExports
| DeclareTypeAlias
| DeclareOpaqueType
| DeclareVariable
| DeclareExportDeclaration
| DeclareExportAllDeclaration
| InterfaceDeclaration
| OpaqueType
| TypeAlias;export type FlowPredicate = DeclaredPredicate | InferredPredicate;export type EnumBody = EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;export type EnumMember = EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember;export type JSX = JSXAttribute
| JSXClosingElement
| JSXElement
| JSXEmptyExpression
| JSXExpressionContainer
| JSXSpreadChild
| JSXIdentifier
| JSXMemberExpression
| JSXNamespacedName
| JSXOpeningElement
| JSXSpreadAttribute
| JSXText
| JSXFragment
| JSXOpeningFragment
| JSXClosingFragment;export type Miscellaneous = Noop | Placeholder | V8IntrinsicIdentifier;export type TypeScript = TSParameterProperty
| TSDeclareFunction
| TSDeclareMethod
| TSQualifiedName
| TSCallSignatureDeclaration
| TSConstructSignatureDeclaration
| TSPropertySignature
| TSMethodSignature
| TSIndexSignature
| TSAnyKeyword
| TSBooleanKeyword
| TSBigIntKeyword
| TSIntrinsicKeyword
| TSNeverKeyword
| TSNullKeyword
| TSNumberKeyword
| TSObjectKeyword
| TSStringKeyword
| TSSymbolKeyword
| TSUndefinedKeyword
| TSUnknownKeyword
| TSVoidKeyword
| TSThisType
| TSFunctionType
| TSConstructorType
| TSTypeReference
| TSTypePredicate
| TSTypeQuery
| TSTypeLiteral
| TSArrayType
| TSTupleType
| TSOptionalType
| TSRestType
| TSNamedTupleMember
| TSUnionType
| TSIntersectionType
| TSConditionalType
| TSInferType
| TSParenthesizedType
| TSTypeOperator
| TSIndexedAccessType
| TSMappedType
| TSLiteralType
| TSExpressionWithTypeArguments
| TSInterfaceDeclaration
| TSInterfaceBody
| TSTypeAliasDeclaration
| TSInstantiationExpression
| TSAsExpression
| TSTypeAssertion
| TSEnumDeclaration
| TSEnumMember
| TSModuleDeclaration
| TSModuleBlock
| TSImportType
| TSImportEqualsDeclaration
| TSExternalModuleReference
| TSNonNullExpression
| TSExportAssignment
| TSNamespaceExportDeclaration
| TSTypeAnnotation
| TSTypeParameterInstantiation
| TSTypeParameterDeclaration
| TSTypeParameter;export type TSTypeElement = TSCallSignatureDeclaration
| TSConstructSignatureDeclaration
| TSPropertySignature
| TSMethodSignature
| TSIndexSignature;export type TSType = TSAnyKeyword
| TSBooleanKeyword
| TSBigIntKeyword
| TSIntrinsicKeyword
| TSNeverKeyword
| TSNullKeyword
| TSNumberKeyword
| TSObjectKeyword
| TSStringKeyword
| TSSymbolKeyword
| TSUndefinedKeyword
| TSUnknownKeyword
| TSVoidKeyword
| TSThisType
| TSFunctionType
| TSConstructorType
| TSTypeReference
| TSTypePredicate
| TSTypeQuery
| TSTypeLiteral
| TSArrayType
| TSTupleType
| TSOptionalType
| TSRestType
| TSUnionType
| TSIntersectionType
| TSConditionalType
| TSInferType
| TSParenthesizedType
| TSTypeOperator
| TSIndexedAccessType
| TSMappedType
| TSLiteralType
| TSExpressionWithTypeArguments
| TSImportType;export type TSBaseType = TSAnyKeyword
| TSBooleanKeyword
| TSBigIntKeyword
| TSIntrinsicKeyword
| TSNeverKeyword
| TSNullKeyword
| TSNumberKeyword
| TSObjectKeyword
| TSStringKeyword
| TSSymbolKeyword
| TSUndefinedKeyword
| TSUnknownKeyword
| TSVoidKeyword
| TSThisType
| TSLiteralType;export interface Aliases {
Standardized: Standardized,
Expression: Expression,
Binary: Binary,
Scopable: Scopable,
BlockParent: BlockParent,
Block: Block,
Statement: Statement,
Terminatorless: Terminatorless,
CompletionStatement: CompletionStatement,
Conditional: Conditional,
Loop: Loop,
While: While,
ExpressionWrapper: ExpressionWrapper,
For: For,
ForXStatement: ForXStatement,
Function: Function,
FunctionParent: FunctionParent,
Pureish: Pureish,
Declaration: Declaration,
PatternLike: PatternLike,
LVal: LVal,
TSEntityName: TSEntityName,
Literal: Literal,
Immutable: Immutable,
UserWhitespacable: UserWhitespacable,
Method: Method,
ObjectMember: ObjectMember,
Property: Property,
UnaryLike: UnaryLike,
Pattern: Pattern,
Class: Class,
ModuleDeclaration: ModuleDeclaration,
ExportDeclaration: ExportDeclaration,
ModuleSpecifier: ModuleSpecifier,
Accessor: Accessor,
Private: Private,
Flow: Flow,
FlowType: FlowType,
FlowBaseAnnotation: FlowBaseAnnotation,
FlowDeclaration: FlowDeclaration,
FlowPredicate: FlowPredicate,
EnumBody: EnumBody,
EnumMember: EnumMember,
JSX: JSX,
Miscellaneous: Miscellaneous,
TypeScript: TypeScript,
TSTypeElement: TSTypeElement,
TSType: TSType,
TSBaseType: TSBaseType,
} declare export function arrayExpression(elements?: Array<null | Expression | SpreadElement>): ArrayExpression
declare export function assignmentExpression(operator: string, left: LVal, right: Expression): AssignmentExpression
declare export function binaryExpression(
operator: "+"
| "-"
| "/"
| "%"
| "*"
| "**"
| "&"
| "|"
| ">>"
| ">>>"
| "<<"
| "^"
| "=="
| "==="
| "!="
| "!=="
| "in"
| "instanceof"
| ">"
| "<"
| ">="
| "<="
| "|>",
left: Expression | PrivateName,
right: Expression): BinaryExpression
declare export function interpreterDirective(value: string): InterpreterDirective
declare export function directive(value: DirectiveLiteral): Directive
declare export function directiveLiteral(value: string): DirectiveLiteral
declare export function blockStatement(body: Array<Statement>, directives?: Array<Directive>): BlockStatement
declare export function breakStatement(label?: Identifier | null): BreakStatement
declare export function callExpression(
callee: Expression | Super | V8IntrinsicIdentifier,
_arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>): CallExpression
declare export function catchClause(
param: Identifier
| ArrayPattern
| ObjectPattern
| null
| void,
body: BlockStatement): CatchClause
declare export function conditionalExpression(
test: Expression,
consequent: Expression,
alternate: Expression): ConditionalExpression
declare export function continueStatement(label?: Identifier | null): ContinueStatement
declare export function debuggerStatement(): DebuggerStatement
declare export function doWhileStatement(test: Expression, body: Statement): DoWhileStatement
declare export function emptyStatement(): EmptyStatement
declare export function expressionStatement(expression: Expression): ExpressionStatement
declare export function file(
program: Program,
comments?: Array<CommentBlock | CommentLine> | null,
tokens?: Array<any> | null): File
declare export function forInStatement(
left: VariableDeclaration | LVal,
right: Expression,
body: Statement): ForInStatement
declare export function forStatement(
init: VariableDeclaration | Expression | null | void,
test: Expression | null | void,
update: Expression | null | void,
body: Statement): ForStatement
declare export function functionDeclaration(
id: Identifier | null | void,
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement,
generator?: boolean,
async?: boolean): FunctionDeclaration
declare export function functionExpression(
id: Identifier | null | void,
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement,
generator?: boolean,
async?: boolean): FunctionExpression
declare export function identifier(name: string): Identifier
declare export function ifStatement(
test: Expression,
consequent: Statement,
alternate?: Statement | null): IfStatement
declare export function labeledStatement(label: Identifier, body: Statement): LabeledStatement
declare export function stringLiteral(value: string): StringLiteral
declare export function numericLiteral(value: number): NumericLiteral
declare export function nullLiteral(): NullLiteral
declare export function booleanLiteral(value: boolean): BooleanLiteral
declare export function regExpLiteral(pattern: string, flags?: string): RegExpLiteral
declare export function logicalExpression(
operator: "||" | "&&" | "??",
left: Expression,
right: Expression): LogicalExpression
declare export function memberExpression(
object: Expression | Super,
property: Expression | Identifier | PrivateName,
computed?: boolean,
optional?: true | false | null): MemberExpression
declare export function newExpression(
callee: Expression | Super | V8IntrinsicIdentifier,
_arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>): NewExpression
declare export function program(
body: Array<Statement>,
directives?: Array<Directive>,
sourceType?: "script" | "module",
interpreter?: InterpreterDirective | null): Program
declare export function objectExpression(
properties: Array<ObjectMethod | ObjectProperty | SpreadElement>): ObjectExpression
declare export function objectMethod(
kind: "method" | "get" | "set" | void,
key: Expression
| Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral,
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement,
computed?: boolean,
generator?: boolean,
async?: boolean): ObjectMethod
declare export function objectProperty(
key: Expression
| Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| DecimalLiteral
| PrivateName,
value: Expression | PatternLike,
computed?: boolean,
shorthand?: boolean,
decorators?: Array<Decorator> | null): ObjectProperty
declare export function restElement(argument: LVal): RestElement
declare export function returnStatement(argument?: Expression | null): ReturnStatement
declare export function sequenceExpression(expressions: Array<Expression>): SequenceExpression
declare export function parenthesizedExpression(expression: Expression): ParenthesizedExpression
declare export function switchCase(test: Expression | null | void, consequent: Array<Statement>): SwitchCase
declare export function switchStatement(discriminant: Expression, cases: Array<SwitchCase>): SwitchStatement
declare export function thisExpression(): ThisExpression
declare export function throwStatement(argument: Expression): ThrowStatement
declare export function tryStatement(
block: BlockStatement,
handler?: CatchClause | null,
finalizer?: BlockStatement | null): TryStatement
declare export function unaryExpression(
operator: "void"
| "throw"
| "delete"
| "!"
| "+"
| "-"
| "~"
| "typeof",
argument: Expression,
prefix?: boolean): UnaryExpression
declare export function updateExpression(
operator: "++" | "--",
argument: Expression,
prefix?: boolean): UpdateExpression
declare export function variableDeclaration(
kind: "var" | "let" | "const",
declarations: Array<VariableDeclarator>): VariableDeclaration
declare export function variableDeclarator(id: LVal, init?: Expression | null): VariableDeclarator
declare export function whileStatement(test: Expression, body: Statement): WhileStatement
declare export function withStatement(object: Expression, body: Statement): WithStatement
declare export function assignmentPattern(
left: Identifier
| ObjectPattern
| ArrayPattern
| MemberExpression
| TSAsExpression
| TSTypeAssertion
| TSNonNullExpression,
right: Expression): AssignmentPattern
declare export function arrayPattern(elements: Array<null | PatternLike | LVal>): ArrayPattern
declare export function arrowFunctionExpression(
params: Array<Identifier | Pattern | RestElement>,
body: BlockStatement | Expression,
async?: boolean): ArrowFunctionExpression
declare export function classBody(
body: Array<ClassMethod
| ClassPrivateMethod
| ClassProperty
| ClassPrivateProperty
| ClassAccessorProperty
| TSDeclareMethod
| TSIndexSignature
| StaticBlock>): ClassBody
declare export function classExpression(
id: Identifier | null | void,
superClass: Expression | null | void,
body: ClassBody,
decorators?: Array<Decorator> | null): ClassExpression
declare export function classDeclaration(
id: Identifier,
superClass: Expression | null | void,
body: ClassBody,
decorators?: Array<Decorator> | null): ClassDeclaration
declare export function exportAllDeclaration(source: StringLiteral): ExportAllDeclaration
declare export function exportDefaultDeclaration(
declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Expression): ExportDefaultDeclaration
declare export function exportNamedDeclaration(
declaration?: Declaration | null,
specifiers?: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>,
source?: StringLiteral | null): ExportNamedDeclaration
declare export function exportSpecifier(local: Identifier, exported: Identifier | StringLiteral): ExportSpecifier
declare export function forOfStatement(
left: VariableDeclaration | LVal,
right: Expression,
body: Statement,
_await?: boolean): ForOfStatement
declare export function importDeclaration(
specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>,
source: StringLiteral): ImportDeclaration
declare export function importDefaultSpecifier(local: Identifier): ImportDefaultSpecifier
declare export function importNamespaceSpecifier(local: Identifier): ImportNamespaceSpecifier
declare export function importSpecifier(local: Identifier, imported: Identifier | StringLiteral): ImportSpecifier
declare export function metaProperty(meta: Identifier, property: Identifier): MetaProperty
declare export function classMethod(
kind: "get"
| "set"
| "method"
| "constructor"
| void,
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression,
params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
body: BlockStatement,
computed?: boolean,
_static?: boolean,
generator?: boolean,
async?: boolean): ClassMethod
declare export function objectPattern(properties: Array<RestElement | ObjectProperty>): ObjectPattern
declare export function spreadElement(argument: Expression): SpreadElement
declare function _super(): Super
declare export {
        _super as super
      }
declare export function taggedTemplateExpression(tag: Expression, quasi: TemplateLiteral): TaggedTemplateExpression
declare export function templateElement(value: {
raw: string,
cooked?: string,...
}, tail?: boolean): TemplateElement
declare export function templateLiteral(
quasis: Array<TemplateElement>,
expressions: Array<Expression | TSType>): TemplateLiteral
declare export function yieldExpression(argument?: Expression | null, delegate?: boolean): YieldExpression
declare export function awaitExpression(argument: Expression): AwaitExpression
declare function _import(): Import
declare export {
        _import as import
      }
declare export function bigIntLiteral(value: string): BigIntLiteral
declare export function exportNamespaceSpecifier(exported: Identifier): ExportNamespaceSpecifier
declare export function optionalMemberExpression(
object: Expression,
property: Expression | Identifier,
computed: boolean | void,
optional: boolean): OptionalMemberExpression
declare export function optionalCallExpression(
callee: Expression,
_arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>,
optional: boolean): OptionalCallExpression
declare export function classProperty(
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression,
value?: Expression | null,
typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null,
decorators?: Array<Decorator> | null,
computed?: boolean,
_static?: boolean): ClassProperty
declare export function classAccessorProperty(
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression
| PrivateName,
value?: Expression | null,
typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null,
decorators?: Array<Decorator> | null,
computed?: boolean,
_static?: boolean): ClassAccessorProperty
declare export function classPrivateProperty(
key: PrivateName,
value?: Expression | null,
decorators?: Array<Decorator> | null,
_static?: boolean): ClassPrivateProperty
declare export function classPrivateMethod(
kind: "get" | "set" | "method" | void,
key: PrivateName,
params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
body: BlockStatement,
_static?: boolean): ClassPrivateMethod
declare export function privateName(id: Identifier): PrivateName
declare export function staticBlock(body: Array<Statement>): StaticBlock
declare export function anyTypeAnnotation(): AnyTypeAnnotation
declare export function arrayTypeAnnotation(elementType: FlowType): ArrayTypeAnnotation
declare export function booleanTypeAnnotation(): BooleanTypeAnnotation
declare export function booleanLiteralTypeAnnotation(value: boolean): BooleanLiteralTypeAnnotation
declare export function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation
declare export function classImplements(
id: Identifier,
typeParameters?: TypeParameterInstantiation | null): ClassImplements
declare export function declareClass(
id: Identifier,
typeParameters: TypeParameterDeclaration | null | void,
_extends: Array<InterfaceExtends> | null | void,
body: ObjectTypeAnnotation): DeclareClass
declare export function declareFunction(id: Identifier): DeclareFunction
declare export function declareInterface(
id: Identifier,
typeParameters: TypeParameterDeclaration | null | void,
_extends: Array<InterfaceExtends> | null | void,
body: ObjectTypeAnnotation): DeclareInterface
declare export function declareModule(
id: Identifier | StringLiteral,
body: BlockStatement,
kind?: "CommonJS" | "ES" | null): DeclareModule
declare export function declareModuleExports(typeAnnotation: TypeAnnotation): DeclareModuleExports
declare export function declareTypeAlias(
id: Identifier,
typeParameters: TypeParameterDeclaration | null | void,
right: FlowType): DeclareTypeAlias
declare export function declareOpaqueType(
id: Identifier,
typeParameters?: TypeParameterDeclaration | null,
supertype?: FlowType | null): DeclareOpaqueType
declare export function declareVariable(id: Identifier): DeclareVariable
declare export function declareExportDeclaration(
declaration?: Flow | null,
specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null,
source?: StringLiteral | null): DeclareExportDeclaration
declare export function declareExportAllDeclaration(source: StringLiteral): DeclareExportAllDeclaration
declare export function declaredPredicate(value: Flow): DeclaredPredicate
declare export function existsTypeAnnotation(): ExistsTypeAnnotation
declare export function functionTypeAnnotation(
typeParameters: TypeParameterDeclaration | null | void,
params: Array<FunctionTypeParam>,
rest: FunctionTypeParam | null | void,
returnType: FlowType): FunctionTypeAnnotation
declare export function functionTypeParam(name: Identifier | null | void, typeAnnotation: FlowType): FunctionTypeParam
declare export function genericTypeAnnotation(
id: Identifier | QualifiedTypeIdentifier,
typeParameters?: TypeParameterInstantiation | null): GenericTypeAnnotation
declare export function inferredPredicate(): InferredPredicate
declare export function interfaceExtends(
id: Identifier | QualifiedTypeIdentifier,
typeParameters?: TypeParameterInstantiation | null): InterfaceExtends
declare export function interfaceDeclaration(
id: Identifier,
typeParameters: TypeParameterDeclaration | null | void,
_extends: Array<InterfaceExtends> | null | void,
body: ObjectTypeAnnotation): InterfaceDeclaration
declare export function interfaceTypeAnnotation(
_extends: Array<InterfaceExtends> | null | void,
body: ObjectTypeAnnotation): InterfaceTypeAnnotation
declare export function intersectionTypeAnnotation(types: Array<FlowType>): IntersectionTypeAnnotation
declare export function mixedTypeAnnotation(): MixedTypeAnnotation
declare export function emptyTypeAnnotation(): EmptyTypeAnnotation
declare export function nullableTypeAnnotation(typeAnnotation: FlowType): NullableTypeAnnotation
declare export function numberLiteralTypeAnnotation(value: number): NumberLiteralTypeAnnotation
declare export function numberTypeAnnotation(): NumberTypeAnnotation
declare export function objectTypeAnnotation(
properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>,
indexers?: Array<ObjectTypeIndexer>,
callProperties?: Array<ObjectTypeCallProperty>,
internalSlots?: Array<ObjectTypeInternalSlot>,
exact?: boolean): ObjectTypeAnnotation
declare export function objectTypeInternalSlot(
id: Identifier,
value: FlowType,
optional: boolean,
_static: boolean,
method: boolean): ObjectTypeInternalSlot
declare export function objectTypeCallProperty(value: FlowType): ObjectTypeCallProperty
declare export function objectTypeIndexer(
id: Identifier | null | void,
key: FlowType,
value: FlowType,
variance?: Variance | null): ObjectTypeIndexer
declare export function objectTypeProperty(
key: Identifier | StringLiteral,
value: FlowType,
variance?: Variance | null): ObjectTypeProperty
declare export function objectTypeSpreadProperty(argument: FlowType): ObjectTypeSpreadProperty
declare export function opaqueType(
id: Identifier,
typeParameters: TypeParameterDeclaration | null | void,
supertype: FlowType | null | void,
impltype: FlowType): OpaqueType
declare export function qualifiedTypeIdentifier(
id: Identifier,
qualification: Identifier | QualifiedTypeIdentifier): QualifiedTypeIdentifier
declare export function stringLiteralTypeAnnotation(value: string): StringLiteralTypeAnnotation
declare export function stringTypeAnnotation(): StringTypeAnnotation
declare export function symbolTypeAnnotation(): SymbolTypeAnnotation
declare export function thisTypeAnnotation(): ThisTypeAnnotation
declare export function tupleTypeAnnotation(types: Array<FlowType>): TupleTypeAnnotation
declare export function typeofTypeAnnotation(argument: FlowType): TypeofTypeAnnotation
declare export function typeAlias(
id: Identifier,
typeParameters: TypeParameterDeclaration | null | void,
right: FlowType): TypeAlias
declare export function typeAnnotation(typeAnnotation: FlowType): TypeAnnotation
declare export function typeCastExpression(expression: Expression, typeAnnotation: TypeAnnotation): TypeCastExpression
declare export function typeParameter(
bound?: TypeAnnotation | null,
_default?: FlowType | null,
variance?: Variance | null): TypeParameter
declare export function typeParameterDeclaration(params: Array<TypeParameter>): TypeParameterDeclaration
declare export function typeParameterInstantiation(params: Array<FlowType>): TypeParameterInstantiation
declare export function unionTypeAnnotation(types: Array<FlowType>): UnionTypeAnnotation
declare export function variance(kind: "minus" | "plus"): Variance
declare export function voidTypeAnnotation(): VoidTypeAnnotation
declare export function enumDeclaration(
id: Identifier,
body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody): EnumDeclaration
declare export function enumBooleanBody(members: Array<EnumBooleanMember>): EnumBooleanBody
declare export function enumNumberBody(members: Array<EnumNumberMember>): EnumNumberBody
declare export function enumStringBody(members: Array<EnumStringMember | EnumDefaultedMember>): EnumStringBody
declare export function enumSymbolBody(members: Array<EnumDefaultedMember>): EnumSymbolBody
declare export function enumBooleanMember(id: Identifier): EnumBooleanMember
declare export function enumNumberMember(id: Identifier, init: NumericLiteral): EnumNumberMember
declare export function enumStringMember(id: Identifier, init: StringLiteral): EnumStringMember
declare export function enumDefaultedMember(id: Identifier): EnumDefaultedMember
declare export function indexedAccessType(objectType: FlowType, indexType: FlowType): IndexedAccessType
declare export function optionalIndexedAccessType(objectType: FlowType, indexType: FlowType): OptionalIndexedAccessType
declare export function jsxAttribute(
name: JSXIdentifier | JSXNamespacedName,
value?: JSXElement
| JSXFragment
| StringLiteral
| JSXExpressionContainer
| null): JSXAttribute
declare export function jsxClosingElement(
name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName): JSXClosingElement
declare export function jsxElement(
openingElement: JSXOpeningElement,
closingElement: JSXClosingElement | null | void,
children: Array<JSXText
| JSXExpressionContainer
| JSXSpreadChild
| JSXElement
| JSXFragment>,
selfClosing?: boolean | null): JSXElement
declare export function jsxEmptyExpression(): JSXEmptyExpression
declare export function jsxExpressionContainer(expression: Expression | JSXEmptyExpression): JSXExpressionContainer
declare export function jsxSpreadChild(expression: Expression): JSXSpreadChild
declare export function jsxIdentifier(name: string): JSXIdentifier
declare export function jsxMemberExpression(
object: JSXMemberExpression | JSXIdentifier,
property: JSXIdentifier): JSXMemberExpression
declare export function jsxNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName
declare export function jsxOpeningElement(
name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
attributes: Array<JSXAttribute | JSXSpreadAttribute>,
selfClosing?: boolean): JSXOpeningElement
declare export function jsxSpreadAttribute(argument: Expression): JSXSpreadAttribute
declare export function jsxText(value: string): JSXText
declare export function jsxFragment(
openingFragment: JSXOpeningFragment,
closingFragment: JSXClosingFragment,
children: Array<JSXText
| JSXExpressionContainer
| JSXSpreadChild
| JSXElement
| JSXFragment>): JSXFragment
declare export function jsxOpeningFragment(): JSXOpeningFragment
declare export function jsxClosingFragment(): JSXClosingFragment
declare export function noop(): Noop
declare export function placeholder(
expectedNode: "Identifier"
| "StringLiteral"
| "Expression"
| "Statement"
| "Declaration"
| "BlockStatement"
| "ClassBody"
| "Pattern",
name: Identifier): Placeholder
declare export function v8IntrinsicIdentifier(name: string): V8IntrinsicIdentifier
declare export function argumentPlaceholder(): ArgumentPlaceholder
declare export function bindExpression(object: Expression, callee: Expression): BindExpression
declare export function importAttribute(key: Identifier | StringLiteral, value: StringLiteral): ImportAttribute
declare export function decorator(expression: Expression): Decorator
declare export function doExpression(body: BlockStatement, async?: boolean): DoExpression
declare export function exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier
declare export function recordExpression(properties: Array<ObjectProperty | SpreadElement>): RecordExpression
declare export function tupleExpression(elements?: Array<Expression | SpreadElement>): TupleExpression
declare export function decimalLiteral(value: string): DecimalLiteral
declare export function moduleExpression(body: Program): ModuleExpression
declare export function topicReference(): TopicReference
declare export function pipelineTopicExpression(expression: Expression): PipelineTopicExpression
declare export function pipelineBareFunction(callee: Expression): PipelineBareFunction
declare export function pipelinePrimaryTopicReference(): PipelinePrimaryTopicReference
declare export function tsParameterProperty(parameter: Identifier | AssignmentPattern): TSParameterProperty
declare export function tsDeclareFunction(
id: Identifier | null | void,
typeParameters: TSTypeParameterDeclaration | Noop | null | void,
params: Array<Identifier | Pattern | RestElement>,
returnType?: TSTypeAnnotation | Noop | null): TSDeclareFunction
declare export function tsDeclareMethod(
decorators: Array<Decorator> | null | void,
key: Identifier
| StringLiteral
| NumericLiteral
| BigIntLiteral
| Expression,
typeParameters: TSTypeParameterDeclaration | Noop | null | void,
params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
returnType?: TSTypeAnnotation | Noop | null): TSDeclareMethod
declare export function tsQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName
declare export function tsCallSignatureDeclaration(
typeParameters: TSTypeParameterDeclaration | null | void,
parameters: Array<Identifier | RestElement>,
typeAnnotation?: TSTypeAnnotation | null): TSCallSignatureDeclaration
declare export function tsConstructSignatureDeclaration(
typeParameters: TSTypeParameterDeclaration | null | void,
parameters: Array<Identifier | RestElement>,
typeAnnotation?: TSTypeAnnotation | null): TSConstructSignatureDeclaration
declare export function tsPropertySignature(
key: Expression,
typeAnnotation?: TSTypeAnnotation | null,
initializer?: Expression | null): TSPropertySignature
declare export function tsMethodSignature(
key: Expression,
typeParameters: TSTypeParameterDeclaration | null | void,
parameters: Array<Identifier | RestElement>,
typeAnnotation?: TSTypeAnnotation | null): TSMethodSignature
declare export function tsIndexSignature(
parameters: Array<Identifier>,
typeAnnotation?: TSTypeAnnotation | null): TSIndexSignature
declare export function tsAnyKeyword(): TSAnyKeyword
declare export function tsBooleanKeyword(): TSBooleanKeyword
declare export function tsBigIntKeyword(): TSBigIntKeyword
declare export function tsIntrinsicKeyword(): TSIntrinsicKeyword
declare export function tsNeverKeyword(): TSNeverKeyword
declare export function tsNullKeyword(): TSNullKeyword
declare export function tsNumberKeyword(): TSNumberKeyword
declare export function tsObjectKeyword(): TSObjectKeyword
declare export function tsStringKeyword(): TSStringKeyword
declare export function tsSymbolKeyword(): TSSymbolKeyword
declare export function tsUndefinedKeyword(): TSUndefinedKeyword
declare export function tsUnknownKeyword(): TSUnknownKeyword
declare export function tsVoidKeyword(): TSVoidKeyword
declare export function tsThisType(): TSThisType
declare export function tsFunctionType(
typeParameters: TSTypeParameterDeclaration | null | void,
parameters: Array<Identifier | RestElement>,
typeAnnotation?: TSTypeAnnotation | null): TSFunctionType
declare export function tsConstructorType(
typeParameters: TSTypeParameterDeclaration | null | void,
parameters: Array<Identifier | RestElement>,
typeAnnotation?: TSTypeAnnotation | null): TSConstructorType
declare export function tsTypeReference(
typeName: TSEntityName,
typeParameters?: TSTypeParameterInstantiation | null): TSTypeReference
declare export function tsTypePredicate(
parameterName: Identifier | TSThisType,
typeAnnotation?: TSTypeAnnotation | null,
asserts?: boolean | null): TSTypePredicate
declare export function tsTypeQuery(
exprName: TSEntityName | TSImportType,
typeParameters?: TSTypeParameterInstantiation | null): TSTypeQuery
declare export function tsTypeLiteral(members: Array<TSTypeElement>): TSTypeLiteral
declare export function tsArrayType(elementType: TSType): TSArrayType
declare export function tsTupleType(elementTypes: Array<TSType | TSNamedTupleMember>): TSTupleType
declare export function tsOptionalType(typeAnnotation: TSType): TSOptionalType
declare export function tsRestType(typeAnnotation: TSType): TSRestType
declare export function tsNamedTupleMember(label: Identifier, elementType: TSType, optional?: boolean): TSNamedTupleMember
declare export function tsUnionType(types: Array<TSType>): TSUnionType
declare export function tsIntersectionType(types: Array<TSType>): TSIntersectionType
declare export function tsConditionalType(
checkType: TSType,
extendsType: TSType,
trueType: TSType,
falseType: TSType): TSConditionalType
declare export function tsInferType(typeParameter: TSTypeParameter): TSInferType
declare export function tsParenthesizedType(typeAnnotation: TSType): TSParenthesizedType
declare export function tsTypeOperator(typeAnnotation: TSType): TSTypeOperator
declare export function tsIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType
declare export function tsMappedType(
typeParameter: TSTypeParameter,
typeAnnotation?: TSType | null,
nameType?: TSType | null): TSMappedType
declare export function tsLiteralType(
literal: NumericLiteral
| StringLiteral
| BooleanLiteral
| BigIntLiteral
| TemplateLiteral
| UnaryExpression): TSLiteralType
declare export function tsExpressionWithTypeArguments(
expression: TSEntityName,
typeParameters?: TSTypeParameterInstantiation | null): TSExpressionWithTypeArguments
declare export function tsInterfaceDeclaration(
id: Identifier,
typeParameters: TSTypeParameterDeclaration | null | void,
_extends: Array<TSExpressionWithTypeArguments> | null | void,
body: TSInterfaceBody): TSInterfaceDeclaration
declare export function tsInterfaceBody(body: Array<TSTypeElement>): TSInterfaceBody
declare export function tsTypeAliasDeclaration(
id: Identifier,
typeParameters: TSTypeParameterDeclaration | null | void,
typeAnnotation: TSType): TSTypeAliasDeclaration
declare export function tsInstantiationExpression(
expression: Expression,
typeParameters?: TSTypeParameterInstantiation | null): TSInstantiationExpression
declare export function tsAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression
declare export function tsTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion
declare export function tsEnumDeclaration(id: Identifier, members: Array<TSEnumMember>): TSEnumDeclaration
declare export function tsEnumMember(id: Identifier | StringLiteral, initializer?: Expression | null): TSEnumMember
declare export function tsModuleDeclaration(
id: Identifier | StringLiteral,
body: TSModuleBlock | TSModuleDeclaration): TSModuleDeclaration
declare export function tsModuleBlock(body: Array<Statement>): TSModuleBlock
declare export function tsImportType(
argument: StringLiteral,
qualifier?: TSEntityName | null,
typeParameters?: TSTypeParameterInstantiation | null): TSImportType
declare export function tsImportEqualsDeclaration(
id: Identifier,
moduleReference: TSEntityName | TSExternalModuleReference): TSImportEqualsDeclaration
declare export function tsExternalModuleReference(expression: StringLiteral): TSExternalModuleReference
declare export function tsNonNullExpression(expression: Expression): TSNonNullExpression
declare export function tsExportAssignment(expression: Expression): TSExportAssignment
declare export function tsNamespaceExportDeclaration(id: Identifier): TSNamespaceExportDeclaration
declare export function tsTypeAnnotation(typeAnnotation: TSType): TSTypeAnnotation
declare export function tsTypeParameterInstantiation(params: Array<TSType>): TSTypeParameterInstantiation
declare export function tsTypeParameterDeclaration(params: Array<TSTypeParameter>): TSTypeParameterDeclaration
declare export function tsTypeParameter(
constraint: TSType | null | void,
_default: TSType | null | void,
name: string): TSTypeParameter
declare export function isAccessor(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertAccessor(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isAnyTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertAnyTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isArgumentPlaceholder(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertArgumentPlaceholder(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isArrayExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertArrayExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isArrayPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertArrayPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isArrayTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertArrayTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isArrowFunctionExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertArrowFunctionExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isAssignmentExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertAssignmentExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isAssignmentPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertAssignmentPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isAwaitExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertAwaitExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBigIntLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBigIntLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBinary(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBinary(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBinaryExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBinaryExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBindExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBindExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBlock(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBlock(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBlockParent(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBlockParent(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBlockStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBlockStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBooleanLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBooleanLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBooleanLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBooleanLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBooleanTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBooleanTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isBreakStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertBreakStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isCallExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertCallExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isCatchClause(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertCatchClause(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClass(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClass(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassAccessorProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassAccessorProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassImplements(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassImplements(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassPrivateMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassPrivateMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassPrivateProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassPrivateProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isClassProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertClassProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isCompletionStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertCompletionStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isConditional(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertConditional(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isConditionalExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertConditionalExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isContinueStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertContinueStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDebuggerStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDebuggerStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDecimalLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDecimalLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareClass(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareClass(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareExportAllDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareExportAllDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareExportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareExportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareInterface(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareInterface(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareModule(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareModule(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareModuleExports(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareModuleExports(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareOpaqueType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareOpaqueType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareTypeAlias(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareTypeAlias(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclareVariable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclareVariable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDeclaredPredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDeclaredPredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDecorator(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDecorator(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDirective(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDirective(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDirectiveLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDirectiveLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDoExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDoExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isDoWhileStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertDoWhileStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEmptyStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEmptyStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEmptyTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEmptyTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumBooleanBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumBooleanBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumBooleanMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumBooleanMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumDefaultedMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumDefaultedMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumNumberBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumNumberBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumNumberMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumNumberMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumStringBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumStringBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumStringMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumStringMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isEnumSymbolBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertEnumSymbolBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExistsTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExistsTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExportAllDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExportAllDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExportDefaultDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExportDefaultDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExportDefaultSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExportDefaultSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExportNamedDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExportNamedDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExportNamespaceSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExportNamespaceSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExportSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExportSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExpressionStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExpressionStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isExpressionWrapper(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertExpressionWrapper(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFile(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFile(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFlow(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFlow(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFlowBaseAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFlowBaseAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFlowDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFlowDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFlowPredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFlowPredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFlowType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFlowType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFor(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFor(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isForInStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertForInStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isForOfStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertForOfStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isForStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertForStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isForXStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertForXStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFunctionDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFunctionDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFunctionExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFunctionExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFunctionParent(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFunctionParent(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFunctionTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFunctionTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isFunctionTypeParam(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertFunctionTypeParam(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isGenericTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertGenericTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isIfStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertIfStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isImmutable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertImmutable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isImport(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertImport(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isImportAttribute(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertImportAttribute(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isImportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertImportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isImportDefaultSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertImportDefaultSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isImportNamespaceSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertImportNamespaceSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isImportSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertImportSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isIndexedAccessType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertIndexedAccessType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isInferredPredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertInferredPredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isInterfaceDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertInterfaceDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isInterfaceExtends(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertInterfaceExtends(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isInterfaceTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertInterfaceTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isInterpreterDirective(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertInterpreterDirective(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isIntersectionTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertIntersectionTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSX(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSX(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXAttribute(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXAttribute(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXClosingElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXClosingElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXClosingFragment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXClosingFragment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXEmptyExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXEmptyExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXExpressionContainer(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXExpressionContainer(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXFragment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXFragment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXMemberExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXMemberExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXNamespacedName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXNamespacedName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXOpeningElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXOpeningElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXOpeningFragment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXOpeningFragment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXSpreadAttribute(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXSpreadAttribute(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXSpreadChild(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXSpreadChild(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isJSXText(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertJSXText(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isLVal(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertLVal(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isLabeledStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertLabeledStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isLogicalExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertLogicalExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isLoop(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertLoop(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isMemberExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertMemberExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isMetaProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertMetaProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isMiscellaneous(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertMiscellaneous(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isMixedTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertMixedTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isModuleDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertModuleDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isModuleExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertModuleExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isModuleSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertModuleSpecifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNewExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNewExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNoop(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNoop(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNullLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNullLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNullLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNullLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNullableTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNullableTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void

/**
 * @deprecated Use `isNumericLiteral`
 */
declare export function isNumberLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean

/**
 * @deprecated Use `assertNumericLiteral`
 */
declare export function assertNumberLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNumberLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNumberLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNumberTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNumberTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isNumericLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertNumericLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectTypeCallProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectTypeCallProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectTypeIndexer(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectTypeIndexer(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectTypeInternalSlot(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectTypeInternalSlot(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectTypeProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectTypeProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isObjectTypeSpreadProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertObjectTypeSpreadProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isOpaqueType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertOpaqueType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isOptionalCallExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertOptionalCallExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isOptionalIndexedAccessType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertOptionalIndexedAccessType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isOptionalMemberExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertOptionalMemberExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isParenthesizedExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertParenthesizedExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPattern(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPatternLike(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPatternLike(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPipelineBareFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPipelineBareFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPipelinePrimaryTopicReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPipelinePrimaryTopicReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPipelineTopicExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPipelineTopicExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPlaceholder(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPlaceholder(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPrivate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPrivate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPrivateName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPrivateName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isProgram(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertProgram(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isPureish(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertPureish(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isQualifiedTypeIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertQualifiedTypeIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isRecordExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertRecordExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isRegExpLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertRegExpLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void

/**
 * @deprecated Use `isRegExpLiteral`
 */
declare export function isRegexLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean

/**
 * @deprecated Use `assertRegExpLiteral`
 */
declare export function assertRegexLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isRestElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertRestElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void

/**
 * @deprecated Use `isRestElement`
 */
declare export function isRestProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean

/**
 * @deprecated Use `assertRestElement`
 */
declare export function assertRestProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isReturnStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertReturnStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isScopable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertScopable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isSequenceExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertSequenceExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isSpreadElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertSpreadElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void

/**
 * @deprecated Use `isSpreadElement`
 */
declare export function isSpreadProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean

/**
 * @deprecated Use `assertSpreadElement`
 */
declare export function assertSpreadProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isStandardized(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertStandardized(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isStaticBlock(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertStaticBlock(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isStringLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertStringLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isStringLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertStringLiteralTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isStringTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertStringTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isSuper(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertSuper(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isSwitchCase(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertSwitchCase(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isSwitchStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertSwitchStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isSymbolTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertSymbolTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSAnyKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSAnyKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSArrayType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSArrayType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSAsExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSAsExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSBaseType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSBaseType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSBigIntKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSBigIntKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSBooleanKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSBooleanKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSCallSignatureDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSCallSignatureDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSConditionalType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSConditionalType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSConstructSignatureDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSConstructSignatureDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSConstructorType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSConstructorType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSDeclareFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSDeclareFunction(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSDeclareMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSDeclareMethod(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSEntityName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSEntityName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSEnumDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSEnumDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSEnumMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSEnumMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSExportAssignment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSExportAssignment(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSExpressionWithTypeArguments(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSExpressionWithTypeArguments(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSExternalModuleReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSExternalModuleReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSFunctionType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSFunctionType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSImportEqualsDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSImportEqualsDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSImportType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSImportType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSIndexSignature(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSIndexSignature(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSIndexedAccessType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSIndexedAccessType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSInferType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSInferType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSInstantiationExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSInstantiationExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSInterfaceBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSInterfaceBody(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSInterfaceDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSInterfaceDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSIntersectionType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSIntersectionType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSIntrinsicKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSIntrinsicKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSLiteralType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSLiteralType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSMappedType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSMappedType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSMethodSignature(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSMethodSignature(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSModuleBlock(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSModuleBlock(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSModuleDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSModuleDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSNamedTupleMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSNamedTupleMember(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSNamespaceExportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSNamespaceExportDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSNeverKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSNeverKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSNonNullExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSNonNullExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSNullKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSNullKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSNumberKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSNumberKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSObjectKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSObjectKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSOptionalType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSOptionalType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSParameterProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSParameterProperty(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSParenthesizedType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSParenthesizedType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSPropertySignature(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSPropertySignature(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSQualifiedName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSQualifiedName(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSRestType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSRestType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSStringKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSStringKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSSymbolKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSSymbolKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSThisType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSThisType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTupleType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTupleType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeAliasDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeAliasDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeAssertion(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeAssertion(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeOperator(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeOperator(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeParameter(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeParameter(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeParameterDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeParameterDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeParameterInstantiation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeParameterInstantiation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypePredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypePredicate(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeQuery(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeQuery(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSTypeReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSTypeReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSUndefinedKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSUndefinedKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSUnionType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSUnionType(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSUnknownKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSUnknownKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTSVoidKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTSVoidKeyword(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTaggedTemplateExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTaggedTemplateExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTemplateElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTemplateElement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTemplateLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTemplateLiteral(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTerminatorless(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTerminatorless(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isThisExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertThisExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isThisTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertThisTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isThrowStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertThrowStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTopicReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTopicReference(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTryStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTryStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTupleExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTupleExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTupleTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTupleTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeAlias(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeAlias(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeCastExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeCastExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeParameter(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeParameter(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeParameterDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeParameterDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeParameterInstantiation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeParameterInstantiation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeScript(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeScript(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isTypeofTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertTypeofTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isUnaryExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertUnaryExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isUnaryLike(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertUnaryLike(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isUnionTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertUnionTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isUpdateExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertUpdateExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isUserWhitespacable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertUserWhitespacable(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isV8IntrinsicIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertV8IntrinsicIdentifier(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isVariableDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertVariableDeclaration(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isVariableDeclarator(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertVariableDeclarator(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isVariance(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertVariance(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isVoidTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertVoidTypeAnnotation(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isWhile(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertWhile(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isWhileStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertWhileStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isWithStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertWithStatement(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function isYieldExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): boolean
declare export function assertYieldExpression(
node: {[key: string]: any} | null | void,
opts?: {[key: string]: any} | null): void
declare export function assertNode(obj: any): void
declare export function createTypeAnnotationBasedOnTypeof(
type: "string"
| "number"
| "undefined"
| "boolean"
| "function"
| "object"
| "symbol"): StringTypeAnnotation
| VoidTypeAnnotation
| NumberTypeAnnotation
| BooleanTypeAnnotation
| GenericTypeAnnotation
declare export function createUnionTypeAnnotation<T: FlowType>(types: [T]): T
declare export function createFlowUnionType<T: FlowType>(types: [T]): T
declare export function createUnionTypeAnnotation(types: $ReadOnlyArray<FlowType>): UnionTypeAnnotation
declare export function createFlowUnionType(types: $ReadOnlyArray<FlowType>): UnionTypeAnnotation
declare export function buildChildren(
node: {
children: $ReadOnlyArray<JSXText
| JSXExpressionContainer
| JSXSpreadChild
| JSXElement
| JSXFragment
| JSXEmptyExpression>,...
}): $PropertyType<JSXElement, "children">
declare export function clone<T: Node>(n: T): T
declare export function cloneDeep<T: Node>(n: T): T
declare export function cloneDeepWithoutLoc<T: Node>(n: T): T
declare export function cloneNode<T: Node>(n: T, deep?: boolean, withoutLoc?: boolean): T
declare export function cloneWithoutLoc<T: Node>(n: T): T
export type CommentTypeShorthand = "leading" | "inner" | "trailing";declare export function addComment<T: Node>(
node: T,
type: CommentTypeShorthand,
content: string,
line?: boolean): T
declare export function addComments<T: Node>(
node: T,
type: CommentTypeShorthand,
comments: $ReadOnlyArray<Comment>): T
declare export function inheritInnerComments(node: Node, parent: Node): void
declare export function inheritLeadingComments(node: Node, parent: Node): void
declare export function inheritsComments<T: Node>(node: T, parent: Node): void
declare export function inheritTrailingComments(node: Node, parent: Node): void
declare export function removeComments<T: Node>(node: T): T
declare export function ensureBlock(
node: Extract<Node, {
body: BlockStatement | Statement | Expression,...
}>): BlockStatement
declare export function ensureBlock<K: $Keys<Extract<Node, {
body: BlockStatement | Statement | Expression,...
}>>>(
node: Extract<Node, {[key: K]: BlockStatement | Statement | Expression, ...}>,
key: K): BlockStatement
declare export function toBindingIdentifierName(name: {
toString(): string,...
} | null | void): string
declare export function toBlock(node: Statement | Expression, parent?: Function | null): BlockStatement
declare export function toComputedKey<T: Extract<Node, {
computed: boolean | null,...
}>>(
node: T,
key?: Expression | Identifier): Expression
declare export function toExpression(node: Function): FunctionExpression
declare export function toExpression(node: Class): ClassExpression
declare export function toExpression(node: ExpressionStatement | Expression | Class | Function): Expression
declare export function toIdentifier(name: {
toString(): string,...
} | null | void): string
declare export function toKeyAlias(node: Method | Property, key?: Node): string
declare export function toSequenceExpression(
nodes: $ReadOnlyArray<Node>,
scope: {
push(value: {
id: LVal,
kind: "var",
init?: Expression,...
}): void,
buildUndefinedNode(): Node,...
}): SequenceExpression | void
declare export function toStatement(node: AssignmentExpression, ignore?: boolean): ExpressionStatement
declare export function toStatement(node: Statement | AssignmentExpression, ignore?: boolean): Statement
declare export function toStatement(node: Class, ignore: true): ClassDeclaration | void
declare export function toStatement(node: Class, ignore?: boolean): ClassDeclaration
declare export function toStatement(node: Function, ignore: true): FunctionDeclaration | void
declare export function toStatement(node: Function, ignore?: boolean): FunctionDeclaration
declare export function toStatement(
node: Statement | Class | Function | AssignmentExpression,
ignore: true): Statement | void
declare export function toStatement(
node: Statement | Class | Function | AssignmentExpression,
ignore?: boolean): Statement
declare export function valueToNode(value: void): Identifier
declare export function valueToNode(value: boolean): BooleanLiteral
declare export function valueToNode(value: null): NullLiteral
declare export function valueToNode(value: string): StringLiteral
declare export function valueToNode(value: number): NumericLiteral | BinaryExpression | UnaryExpression
declare export function valueToNode(value: RegExp): RegExpLiteral
declare export function valueToNode(
value: $ReadOnlyArray<void
| boolean
| null
| string
| number
| RegExp
| {[key: string]: any}>): ArrayExpression
declare export function valueToNode(value: {[key: string]: any}): ObjectExpression
declare export function valueToNode(
value: void
| boolean
| null
| string
| number
| RegExp
| {[key: string]: any}): Expression
declare export function removeTypeDuplicates(types: $ReadOnlyArray<FlowType | false | null | void>): FlowType[]
declare export function appendToMemberExpression<T: Pick<MemberExpression, "object" | "property">>(
member: T,
append: $PropertyType<MemberExpression, "property">,
computed?: boolean): T
declare export function inherits<T: Node | null | void>(child: T, parent: Node | null | void): T
declare export function prependToMemberExpression<T: Pick<MemberExpression, "object" | "property">>(
member: T,
prepend: $PropertyType<MemberExpression, "object">): T
declare export function removeProperties(n: Node, opts?: {
preserveComments: boolean,...
} | null): void
declare export function removePropertiesDeep<T: Node>(n: T, opts?: {
preserveComments: boolean,...
} | null): T
declare export function getBindingIdentifiers(
node: Node,
duplicates: true,
outerOnly?: boolean): {[key: string]: Array<Identifier>, ...}
declare export function getBindingIdentifiers(
node: Node,
duplicates?: false,
outerOnly?: boolean): {[key: string]: Identifier, ...}
declare export function getBindingIdentifiers(
node: Node,
duplicates: boolean,
outerOnly?: boolean): {[key: string]: Identifier | Array<Identifier>, ...}
declare export function getOuterBindingIdentifiers(node: Node, duplicates: true): {[key: string]: Array<Identifier>, ...}
declare export function getOuterBindingIdentifiers(node: Node, duplicates?: false): {[key: string]: Identifier, ...}
declare export function getOuterBindingIdentifiers(
node: Node,
duplicates: boolean): {[key: string]: Identifier | Array<Identifier>, ...}
export type TraversalAncestors = $ReadOnlyArray<{
node: Node,
key: string,
index?: number,...
}>;export type TraversalHandler<T> = (node: Node, parent: TraversalAncestors, type: T) => void;export type TraversalHandlers<T> = {
enter?: TraversalHandler<T>,
exit?: TraversalHandler<T>,...
};declare export function traverse<T>(n: Node, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void
declare export function traverseFast<T>(n: Node, h: TraversalHandler<T>, state?: T): void
declare export function shallowEqual<T: {[key: string]: any}>(actual: {[key: string]: any}, expected: T): boolean
declare export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (node: Node | null | void) => boolean
declare export function is<T: $PropertyType<Node, "type">>(
type: T,
n: Node | null | void,
required?: void): boolean
declare export function is<T: $PropertyType<Node, "type">, P: Extract<Node, {
type: T,...
}>>(
type: T,
n: Node | null | void,
required: $Rest<P, {...}>): boolean
declare export function is<P: Node>(
type: string,
n: Node | null | void,
required: $Rest<P, {...}>): boolean
declare export function is(type: string, n: Node | null | void, required?: $Rest<Node, {...}>): boolean
declare export function isBinding(node: Node, parent: Node, grandparent?: Node): boolean
declare export function isBlockScoped(node: Node): boolean
declare export function isImmutable(node: Node): boolean
declare export function isLet(node: Node): boolean
declare export function isNode(node: {[key: string]: any} | null | void): boolean
declare export function isNodesEquivalent<T: $Rest<Node, {...}>>(a: T, b: any): boolean
declare export function isNodesEquivalent(a: any, b: any): boolean
declare export function isPlaceholderType(
placeholderType: $PropertyType<Node, "type">,
targetType: $PropertyType<Node, "type">): boolean
declare export function isReferenced(node: Node, parent: Node, grandparent?: Node): boolean
declare export function isScope(node: Node, parent: Node): boolean
declare export function isSpecifierDefault(specifier: ModuleSpecifier): boolean
declare export function isType<T: $PropertyType<Node, "type">>(nodetype: string, targetType: T): boolean
declare export function isType(nodetype: string | null | void, targetType: string): boolean
declare export function isValidES3Identifier(name: string): boolean
declare export function isValidIdentifier(name: string): boolean
declare export function isVar(node: Node): boolean
declare export function matchesPattern(
node: Node | null | void,
match: string | $ReadOnlyArray<string>,
allowPartial?: boolean): boolean
declare export function validate<T: Node, K: $Keys<T>>(
n: Node | null | void,
key: K,
value: $ElementType<T, K>): void
declare export function validate(n: Node, key: string, value: any): void

}

/**
 * We include stubs for each file inside this npm package in case you need to
 * require those files directly. Feel free to delete any files that aren't
 * needed.
 */
declare module '@babel/types/lib/asserts/assertNode' {
  declare module.exports: any;
}

declare module '@babel/types/lib/asserts/generated' {
  declare module.exports: any;
}

declare module '@babel/types/lib/ast-types/generated' {
  declare module.exports: any;
}

declare module '@babel/types/lib/builders/flow/createFlowUnionType' {
  declare module.exports: any;
}

declare module '@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof' {
  declare module.exports: any;
}

declare module '@babel/types/lib/builders/generated' {
  declare module.exports: any;
}

declare module '@babel/types/lib/builders/generated/uppercase' {
  declare module.exports: any;
}

declare module '@babel/types/lib/builders/react/buildChildren' {
  declare module.exports: any;
}

declare module '@babel/types/lib/builders/typescript/createTSUnionType' {
  declare module.exports: any;
}

declare module '@babel/types/lib/builders/validateNode' {
  declare module.exports: any;
}

declare module '@babel/types/lib/clone/clone' {
  declare module.exports: any;
}

declare module '@babel/types/lib/clone/cloneDeep' {
  declare module.exports: any;
}

declare module '@babel/types/lib/clone/cloneDeepWithoutLoc' {
  declare module.exports: any;
}

declare module '@babel/types/lib/clone/cloneNode' {
  declare module.exports: any;
}

declare module '@babel/types/lib/clone/cloneWithoutLoc' {
  declare module.exports: any;
}

declare module '@babel/types/lib/comments/addComment' {
  declare module.exports: any;
}

declare module '@babel/types/lib/comments/addComments' {
  declare module.exports: any;
}

declare module '@babel/types/lib/comments/inheritInnerComments' {
  declare module.exports: any;
}

declare module '@babel/types/lib/comments/inheritLeadingComments' {
  declare module.exports: any;
}

declare module '@babel/types/lib/comments/inheritsComments' {
  declare module.exports: any;
}

declare module '@babel/types/lib/comments/inheritTrailingComments' {
  declare module.exports: any;
}

declare module '@babel/types/lib/comments/removeComments' {
  declare module.exports: any;
}

declare module '@babel/types/lib/constants/generated' {
  declare module.exports: any;
}

declare module '@babel/types/lib/constants' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/ensureBlock' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/gatherSequenceExpressions' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toBindingIdentifierName' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toBlock' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toComputedKey' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toExpression' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toIdentifier' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toKeyAlias' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toSequenceExpression' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/toStatement' {
  declare module.exports: any;
}

declare module '@babel/types/lib/converters/valueToNode' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/core' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/experimental' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/flow' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/jsx' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/misc' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/placeholders' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/typescript' {
  declare module.exports: any;
}

declare module '@babel/types/lib/definitions/utils' {
  declare module.exports: any;
}

declare module '@babel/types/lib' {
  declare module.exports: any;
}

declare module '@babel/types/lib/modifications/appendToMemberExpression' {
  declare module.exports: any;
}

declare module '@babel/types/lib/modifications/flow/removeTypeDuplicates' {
  declare module.exports: any;
}

declare module '@babel/types/lib/modifications/inherits' {
  declare module.exports: any;
}

declare module '@babel/types/lib/modifications/prependToMemberExpression' {
  declare module.exports: any;
}

declare module '@babel/types/lib/modifications/removeProperties' {
  declare module.exports: any;
}

declare module '@babel/types/lib/modifications/removePropertiesDeep' {
  declare module.exports: any;
}

declare module '@babel/types/lib/modifications/typescript/removeTypeDuplicates' {
  declare module.exports: any;
}

declare module '@babel/types/lib/retrievers/getBindingIdentifiers' {
  declare module.exports: any;
}

declare module '@babel/types/lib/retrievers/getOuterBindingIdentifiers' {
  declare module.exports: any;
}

declare module '@babel/types/lib/traverse/traverse' {
  declare module.exports: any;
}

declare module '@babel/types/lib/traverse/traverseFast' {
  declare module.exports: any;
}

declare module '@babel/types/lib/utils/inherit' {
  declare module.exports: any;
}

declare module '@babel/types/lib/utils/react/cleanJSXElementLiteralChild' {
  declare module.exports: any;
}

declare module '@babel/types/lib/utils/shallowEqual' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/buildMatchMemberExpression' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/generated' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/is' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isBinding' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isBlockScoped' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isImmutable' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isLet' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isNode' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isNodesEquivalent' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isPlaceholderType' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isReferenced' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isScope' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isSpecifierDefault' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isType' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isValidES3Identifier' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isValidIdentifier' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/isVar' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/matchesPattern' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/react/isCompatTag' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/react/isReactComponent' {
  declare module.exports: any;
}

declare module '@babel/types/lib/validators/validate' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/asserts' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/ast-types' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/builders' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/constants' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/docs' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/flow' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/typescript-legacy' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/generators/validators' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/utils/formatBuilderName' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/utils/lowerFirst' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/utils/stringifyValidator' {
  declare module.exports: any;
}

declare module '@babel/types/scripts/utils/toFunctionName' {
  declare module.exports: any;
}

// Filename aliases
declare module '@babel/types/lib/asserts/assertNode.js' {
  declare module.exports: $Exports<'@babel/types/lib/asserts/assertNode'>;
}
declare module '@babel/types/lib/asserts/generated/index' {
  declare module.exports: $Exports<'@babel/types/lib/asserts/generated'>;
}
declare module '@babel/types/lib/asserts/generated/index.js' {
  declare module.exports: $Exports<'@babel/types/lib/asserts/generated'>;
}
declare module '@babel/types/lib/ast-types/generated/index' {
  declare module.exports: $Exports<'@babel/types/lib/ast-types/generated'>;
}
declare module '@babel/types/lib/ast-types/generated/index.js' {
  declare module.exports: $Exports<'@babel/types/lib/ast-types/generated'>;
}
declare module '@babel/types/lib/builders/flow/createFlowUnionType.js' {
  declare module.exports: $Exports<'@babel/types/lib/builders/flow/createFlowUnionType'>;
}
declare module '@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js' {
  declare module.exports: $Exports<'@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof'>;
}
declare module '@babel/types/lib/builders/generated/index' {
  declare module.exports: $Exports<'@babel/types/lib/builders/generated'>;
}
declare module '@babel/types/lib/builders/generated/index.js' {
  declare module.exports: $Exports<'@babel/types/lib/builders/generated'>;
}
declare module '@babel/types/lib/builders/generated/uppercase.js' {
  declare module.exports: $Exports<'@babel/types/lib/builders/generated/uppercase'>;
}
declare module '@babel/types/lib/builders/react/buildChildren.js' {
  declare module.exports: $Exports<'@babel/types/lib/builders/react/buildChildren'>;
}
declare module '@babel/types/lib/builders/typescript/createTSUnionType.js' {
  declare module.exports: $Exports<'@babel/types/lib/builders/typescript/createTSUnionType'>;
}
declare module '@babel/types/lib/builders/validateNode.js' {
  declare module.exports: $Exports<'@babel/types/lib/builders/validateNode'>;
}
declare module '@babel/types/lib/clone/clone.js' {
  declare module.exports: $Exports<'@babel/types/lib/clone/clone'>;
}
declare module '@babel/types/lib/clone/cloneDeep.js' {
  declare module.exports: $Exports<'@babel/types/lib/clone/cloneDeep'>;
}
declare module '@babel/types/lib/clone/cloneDeepWithoutLoc.js' {
  declare module.exports: $Exports<'@babel/types/lib/clone/cloneDeepWithoutLoc'>;
}
declare module '@babel/types/lib/clone/cloneNode.js' {
  declare module.exports: $Exports<'@babel/types/lib/clone/cloneNode'>;
}
declare module '@babel/types/lib/clone/cloneWithoutLoc.js' {
  declare module.exports: $Exports<'@babel/types/lib/clone/cloneWithoutLoc'>;
}
declare module '@babel/types/lib/comments/addComment.js' {
  declare module.exports: $Exports<'@babel/types/lib/comments/addComment'>;
}
declare module '@babel/types/lib/comments/addComments.js' {
  declare module.exports: $Exports<'@babel/types/lib/comments/addComments'>;
}
declare module '@babel/types/lib/comments/inheritInnerComments.js' {
  declare module.exports: $Exports<'@babel/types/lib/comments/inheritInnerComments'>;
}
declare module '@babel/types/lib/comments/inheritLeadingComments.js' {
  declare module.exports: $Exports<'@babel/types/lib/comments/inheritLeadingComments'>;
}
declare module '@babel/types/lib/comments/inheritsComments.js' {
  declare module.exports: $Exports<'@babel/types/lib/comments/inheritsComments'>;
}
declare module '@babel/types/lib/comments/inheritTrailingComments.js' {
  declare module.exports: $Exports<'@babel/types/lib/comments/inheritTrailingComments'>;
}
declare module '@babel/types/lib/comments/removeComments.js' {
  declare module.exports: $Exports<'@babel/types/lib/comments/removeComments'>;
}
declare module '@babel/types/lib/constants/generated/index' {
  declare module.exports: $Exports<'@babel/types/lib/constants/generated'>;
}
declare module '@babel/types/lib/constants/generated/index.js' {
  declare module.exports: $Exports<'@babel/types/lib/constants/generated'>;
}
declare module '@babel/types/lib/constants/index' {
  declare module.exports: $Exports<'@babel/types/lib/constants'>;
}
declare module '@babel/types/lib/constants/index.js' {
  declare module.exports: $Exports<'@babel/types/lib/constants'>;
}
declare module '@babel/types/lib/converters/ensureBlock.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/ensureBlock'>;
}
declare module '@babel/types/lib/converters/gatherSequenceExpressions.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/gatherSequenceExpressions'>;
}
declare module '@babel/types/lib/converters/toBindingIdentifierName.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toBindingIdentifierName'>;
}
declare module '@babel/types/lib/converters/toBlock.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toBlock'>;
}
declare module '@babel/types/lib/converters/toComputedKey.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toComputedKey'>;
}
declare module '@babel/types/lib/converters/toExpression.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toExpression'>;
}
declare module '@babel/types/lib/converters/toIdentifier.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toIdentifier'>;
}
declare module '@babel/types/lib/converters/toKeyAlias.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toKeyAlias'>;
}
declare module '@babel/types/lib/converters/toSequenceExpression.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toSequenceExpression'>;
}
declare module '@babel/types/lib/converters/toStatement.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/toStatement'>;
}
declare module '@babel/types/lib/converters/valueToNode.js' {
  declare module.exports: $Exports<'@babel/types/lib/converters/valueToNode'>;
}
declare module '@babel/types/lib/definitions/core.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/core'>;
}
declare module '@babel/types/lib/definitions/experimental.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/experimental'>;
}
declare module '@babel/types/lib/definitions/flow.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/flow'>;
}
declare module '@babel/types/lib/definitions/index' {
  declare module.exports: $Exports<'@babel/types/lib/definitions'>;
}
declare module '@babel/types/lib/definitions/index.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions'>;
}
declare module '@babel/types/lib/definitions/jsx.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/jsx'>;
}
declare module '@babel/types/lib/definitions/misc.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/misc'>;
}
declare module '@babel/types/lib/definitions/placeholders.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/placeholders'>;
}
declare module '@babel/types/lib/definitions/typescript.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/typescript'>;
}
declare module '@babel/types/lib/definitions/utils.js' {
  declare module.exports: $Exports<'@babel/types/lib/definitions/utils'>;
}
declare module '@babel/types/lib/index' {
  declare module.exports: $Exports<'@babel/types/lib'>;
}
declare module '@babel/types/lib/index.js' {
  declare module.exports: $Exports<'@babel/types/lib'>;
}
declare module '@babel/types/lib/modifications/appendToMemberExpression.js' {
  declare module.exports: $Exports<'@babel/types/lib/modifications/appendToMemberExpression'>;
}
declare module '@babel/types/lib/modifications/flow/removeTypeDuplicates.js' {
  declare module.exports: $Exports<'@babel/types/lib/modifications/flow/removeTypeDuplicates'>;
}
declare module '@babel/types/lib/modifications/inherits.js' {
  declare module.exports: $Exports<'@babel/types/lib/modifications/inherits'>;
}
declare module '@babel/types/lib/modifications/prependToMemberExpression.js' {
  declare module.exports: $Exports<'@babel/types/lib/modifications/prependToMemberExpression'>;
}
declare module '@babel/types/lib/modifications/removeProperties.js' {
  declare module.exports: $Exports<'@babel/types/lib/modifications/removeProperties'>;
}
declare module '@babel/types/lib/modifications/removePropertiesDeep.js' {
  declare module.exports: $Exports<'@babel/types/lib/modifications/removePropertiesDeep'>;
}
declare module '@babel/types/lib/modifications/typescript/removeTypeDuplicates.js' {
  declare module.exports: $Exports<'@babel/types/lib/modifications/typescript/removeTypeDuplicates'>;
}
declare module '@babel/types/lib/retrievers/getBindingIdentifiers.js' {
  declare module.exports: $Exports<'@babel/types/lib/retrievers/getBindingIdentifiers'>;
}
declare module '@babel/types/lib/retrievers/getOuterBindingIdentifiers.js' {
  declare module.exports: $Exports<'@babel/types/lib/retrievers/getOuterBindingIdentifiers'>;
}
declare module '@babel/types/lib/traverse/traverse.js' {
  declare module.exports: $Exports<'@babel/types/lib/traverse/traverse'>;
}
declare module '@babel/types/lib/traverse/traverseFast.js' {
  declare module.exports: $Exports<'@babel/types/lib/traverse/traverseFast'>;
}
declare module '@babel/types/lib/utils/inherit.js' {
  declare module.exports: $Exports<'@babel/types/lib/utils/inherit'>;
}
declare module '@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js' {
  declare module.exports: $Exports<'@babel/types/lib/utils/react/cleanJSXElementLiteralChild'>;
}
declare module '@babel/types/lib/utils/shallowEqual.js' {
  declare module.exports: $Exports<'@babel/types/lib/utils/shallowEqual'>;
}
declare module '@babel/types/lib/validators/buildMatchMemberExpression.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/buildMatchMemberExpression'>;
}
declare module '@babel/types/lib/validators/generated/index' {
  declare module.exports: $Exports<'@babel/types/lib/validators/generated'>;
}
declare module '@babel/types/lib/validators/generated/index.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/generated'>;
}
declare module '@babel/types/lib/validators/is.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/is'>;
}
declare module '@babel/types/lib/validators/isBinding.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isBinding'>;
}
declare module '@babel/types/lib/validators/isBlockScoped.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isBlockScoped'>;
}
declare module '@babel/types/lib/validators/isImmutable.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isImmutable'>;
}
declare module '@babel/types/lib/validators/isLet.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isLet'>;
}
declare module '@babel/types/lib/validators/isNode.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isNode'>;
}
declare module '@babel/types/lib/validators/isNodesEquivalent.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isNodesEquivalent'>;
}
declare module '@babel/types/lib/validators/isPlaceholderType.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isPlaceholderType'>;
}
declare module '@babel/types/lib/validators/isReferenced.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isReferenced'>;
}
declare module '@babel/types/lib/validators/isScope.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isScope'>;
}
declare module '@babel/types/lib/validators/isSpecifierDefault.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isSpecifierDefault'>;
}
declare module '@babel/types/lib/validators/isType.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isType'>;
}
declare module '@babel/types/lib/validators/isValidES3Identifier.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isValidES3Identifier'>;
}
declare module '@babel/types/lib/validators/isValidIdentifier.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isValidIdentifier'>;
}
declare module '@babel/types/lib/validators/isVar.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/isVar'>;
}
declare module '@babel/types/lib/validators/matchesPattern.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/matchesPattern'>;
}
declare module '@babel/types/lib/validators/react/isCompatTag.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/react/isCompatTag'>;
}
declare module '@babel/types/lib/validators/react/isReactComponent.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/react/isReactComponent'>;
}
declare module '@babel/types/lib/validators/validate.js' {
  declare module.exports: $Exports<'@babel/types/lib/validators/validate'>;
}
declare module '@babel/types/scripts/generators/asserts.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/asserts'>;
}
declare module '@babel/types/scripts/generators/ast-types.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/ast-types'>;
}
declare module '@babel/types/scripts/generators/builders.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/builders'>;
}
declare module '@babel/types/scripts/generators/constants.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/constants'>;
}
declare module '@babel/types/scripts/generators/docs.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/docs'>;
}
declare module '@babel/types/scripts/generators/flow.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/flow'>;
}
declare module '@babel/types/scripts/generators/typescript-legacy.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/typescript-legacy'>;
}
declare module '@babel/types/scripts/generators/validators.js' {
  declare module.exports: $Exports<'@babel/types/scripts/generators/validators'>;
}
declare module '@babel/types/scripts/utils/formatBuilderName.js' {
  declare module.exports: $Exports<'@babel/types/scripts/utils/formatBuilderName'>;
}
declare module '@babel/types/scripts/utils/lowerFirst.js' {
  declare module.exports: $Exports<'@babel/types/scripts/utils/lowerFirst'>;
}
declare module '@babel/types/scripts/utils/stringifyValidator.js' {
  declare module.exports: $Exports<'@babel/types/scripts/utils/stringifyValidator'>;
}
declare module '@babel/types/scripts/utils/toFunctionName.js' {
  declare module.exports: $Exports<'@babel/types/scripts/utils/toFunctionName'>;
}
